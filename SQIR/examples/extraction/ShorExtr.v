(* This file contains code for extracting the Shor's formalism to OCaml. We 
   currently extract Coq real numbers (used in U_R parameters) to OCaml floats.
   This is not ideal for two reasons: (1) floats are not a faithful 
   representation of real numbers, so we lose some guarantees from verification 
   and (2) once we extract to floats, gates get ugly, which could be a problem for
   compilers (e.g. the compiler may have a special rule for H, which we translate
   to U_R 3.14.. 0 1.57..).

   A potential solution to this is to switch the formalism and proofs to a
   different gate set like the following, which uses rationals instead of reals.

Inductive ext_Unitary : nat -> Set := 
  | U_R    : Q -> Q -> Q -> ext_Unitary 1
  | U_CNOT : ext_Unitary 2.

Definition H {dim} n : ext_ucom dim := uapp1 (U_R (1/2) 0 1) n.  
Definition X {dim} n : ext_ucom dim := uapp1 (U_R 1 0 1) n.
...

   That being said, the rest of the quantum software stack (e.g. OpenQASM
   format, simulator) use floating point numbers so we'll have to give up on
   perfect precision at some point.
*)

Require Coq.extraction.Extraction.
Require Import Shor.

(* Standard utilities for bools, options, etc. *)
Require Coq.extraction.ExtrOcamlBasic.

(* A few common functions not included in ExtrOcamlBasic. *)
Extract Inlined Constant fst => "fst".
Extract Inlined Constant snd => "snd".
Extract Inlined Constant negb => "not".
Extract Inlined Constant length => "List.length".
Extract Inlined Constant app => "List.append".
Extract Inlined Constant rev => "List.rev".
Extract Inlined Constant rev_append => "List.rev_append".
Extract Inlined Constant fold_right => "(fun f a l -> List.fold_right f l a)".
Extract Inlined Constant forallb => "List.for_all".

(* Standard extraction from nat -> OCaml int. *)
Require Coq.extraction.ExtrOcamlNatInt.

(* Custom extraction from R -> OCaml float. *)
Extract Constant R => "float".
Extract Constant R0 => "0.0".
Extract Constant R1 => "1.0".
Extract Constant Rplus => "( +. )".
Extract Constant Rmult => "( *. )".
Extract Constant Ropp => "((-.) 0.0)".
Extract Constant Rinv => "((/.) 1.0)".
Extract Constant Rdiv => "( /. )".
Extract Inlined Constant cos => "cos".
Extract Inlined Constant sin => "sin".
Extract Constant PI => "Float.pi".
Extract Inlined Constant Rle_dec => "( <= )".

(* Set "dim" to be implicit everywhere. *)
Extraction Implicit H [dim].
Extraction Implicit X [dim].
Extraction Implicit ID [dim].
Extraction Implicit SKIP [dim].
Extraction Implicit Rz [dim].
Extraction Implicit T [dim].
Extraction Implicit TDAG [dim].
Extraction Implicit CNOT [dim].
Extraction Implicit SWAP [dim].


(* special extraction for modular exponentiation so we don't run into 
   efficiency issues (this is a littele hacky -- it would be better to
   extract all operations to OCaml's Z type). *)
Definition modexp a x N := a ^ x mod N.
Extract Constant modexp => "fun a x n -> Z.to_int (Z.powm (Z.of_int a) (Z.of_int x) (Z.of_int n))".

(* @Liyi: you can change the adder by commenting/uncommenting the following definitions *)
Require Import RCIRplus.

(* Old defn *)
(*Definition modmult_circuit a ainv N n i := 
  @bc2ucom (n + ModMult.modmult_rev_anc n) 
           (RCIR.csplit (RCIR.bcelim (ModMult.modmult_rev N (modexp a (2 ^ i) N) (modexp ainv (2 ^ i) N) n))).
Definition num_qubits n : nat := n + modmult_rev_anc n.*)

(* New defn #1 *)
(*Definition modmult_circuit a ainv N n i :=
  fst (modmult_sqir N (modexp a (2 ^ i) N) (modexp ainv (2 ^ i) N) n).
Definition num_qubits n : nat := get_dim (modmult_vars n).*)

(* New defn #2 *)
Definition modmult_circuit a ainv N n i := 
  fst (rz_mod_sqir N (modexp a (2 ^ i) N) (modexp ainv (2 ^ i) N) n).
Definition num_qubits n : nat := get_dim (rz_mod_vars n).

(* requires 0 < a < N, gcd a N = 1 
   returns a circuit + the number of qubits used *)
Local Open Scope ucom_scope.
Definition shor_circuit a N := 
  let m := Nat.log2 (2 * N^2)%nat in
  let n := Nat.log2 (2 * N) in
  let ainv := modinv a N in
  let numq := num_qubits n in
  let f i := modmult_circuit a ainv N n i in
  (SQIR.X (m + n - 1); QPE_var m numq f, (m + numq)%nat, m).

(* rewritten to use "modexp" *)
Fixpoint OF_post' (step a N o m : nat) :=
  match step with
  | O => O
  | S step' => let pre := OF_post' step' a N o m in
              if (pre =? O) then
                (if (modexp a (OF_post_step step' o m) N =? 1) then OF_post_step step' o m
                 else O)
              else pre
  end.
Definition OF_post a N o m := OF_post' (2 * m + 2) a N o m.

Definition post_process (a N o : nat) := 
  let m := Nat.log2 (2 * N^2)%nat in
  OF_post a N o m.

Separate Extraction shor_circuit post_process 
  (* also, always extract all adder variants *)
  Shor.modmult_circuit modmult_sqir rz_mod_sqir Nat.ltb.

(* Shor's algorithm:

1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_m ∣1⟩_n ∣0⟩_anc.
2. Measure the first m qubits, resulting in the m-bit number x.
3. Run (post_process a N x) to obtain Some(p,q) where p and q are nontrivial factors of N or None 
     (... or something like that)

The main correctness theorem in Shor.v (Shor_correct_full_implementation) 
guarantees that there exists a β > 0 s.t.for any 0 < a < N with gcd a N = 1,
the above algorithm returns Some(p,q) with probability >= β / (Nat.log2 N)^4. 
    (... or something like that)
    
TODO: Add proofs here of the claim above.
(The proofs will likely just call Shor_correct_full_implementation.)

(* The post-processing of Shor's algorithm is simply running continued fraction algorithm step by step. Each time a classical verifier examines whether the denominator is the order.
   OF_post outputs a candidate of the order r. It might still not be the order, but 0 or a multiple of the order. We proved with no less than 1/polylog(N) probability its output is r. *)
*)
 

