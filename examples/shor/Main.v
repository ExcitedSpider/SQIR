Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

   Inputs:
     N = number to factor
     rnds = stream of random real values
     i = index into rnds
     niter = max number of iterations
   
   Output:
     None or Some x where x is a nontrivial factor of N.

   Algorithm: Up to a maximum number of iterations, select "a" uniformly from 
   [2,n-1] and
     1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
     2. Measure the first n qubits, resulting in the n-bit number x.
     3. Run continued fraction expansion (= OF_post) to get r, which is a 
        candidate for the order (ord a N).
     4. Use r to try to factor N.

  The probability of success (returning Some) and the resources (aka qubits and 
  gates) used is a function of N and niter (see proofs below). *)

(* Uniform sampling in the range [lower, upper) *)
Definition uniform (lower upper : nat) : list R :=
  repeat 0 lower ++ repeat (1/ INR (upper - lower))%R (upper - lower).

Definition shor_body a N rnd :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure (to_base_ucom (n + k) circ) rnd in
  let r := OF_post a N x n in
  factor a N r.

Fixpoint end_to_end_shors N (rnds : nat -> R) i niter :=
  match niter with
  | 0 => None
  | S niter' =>
      let a := sample (uniform 1 N) (rnds i) in
      if Nat.gcd a N =? 1%nat
      then 
        match shor_body a N (rnds (S i)) with
        | None => end_to_end_shors N rnds (S (S i)) niter'
        | Some f => Some f
        end
      else (* lucky case: "a" gives us factor directly *)
        Some (Nat.gcd a N)
  end.

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

(** Correctness properties for Shor's **)

Lemma nth_run_probability_of_outcome : forall n (c : base_ucom n) x,
  (x < 2 ^ n)%nat ->
  nth x (run c) 0 
    = probability_of_outcome 
        (basis_vector (2^n) x) 
        (UnitarySem.uc_eval c × basis_vector (2^n) 0).
Proof.
  intros n c x Hx.
  unfold run, probability_of_outcome.
  rewrite nth_indep with (d':=Cmod2 0).
  rewrite map_nth.
  remember (UnitarySem.uc_eval c × basis_vector (2 ^ n) 0) as ψ.
  rewrite nth_vec_to_list by assumption.
  rewrite (basis_vector_decomp ψ) at 2.
  rewrite Mmult_vsum_distr_l.
  symmetry.
  erewrite vsum_unique.
  2 : { exists x. split. assumption. 
        split.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_eq.
        reflexivity. assumption.
        intros y Hy Hxy.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_neq by auto.
        lma. }
  unfold Cmod, Cmod2.
  rewrite pow2_sqrt.
  unfold I, scale.
  simpl.
  lra.
  apply Rplus_le_le_0_compat; apply pow2_ge_0.
  subst. 
  apply WF_mult.
  apply WF_uc_eval.
  apply basis_vector_WF.
  apply pow_positive. lia.
  rewrite map_length.  
  rewrite vec_to_list_length.
  assumption.
Qed.

(* Return the first m bits of x as an int. *)
Definition first_m m n x :=
  (x / 2^n) mod (2^m).

Lemma simplify_first_m : forall m n x y,
  (x < 2 ^ m)%nat ->
  (y < 2 ^ n)%nat ->
  first_m m n (x * 2 ^ n + y) = x.
Proof.
  intros m n x y Hx Hy.
  unfold first_m.
  assert (0 < 2^n)%nat by (apply pow_positive; lia).
  rewrite Nat.div_add_l by lia.
  rewrite Nat.div_small by lia.
  rewrite Nat.mod_small by lia.
  lia.
Qed.

Lemma Rsum_plus_range : forall m n f,
  Rsum (m + n) f = (Rsum m f + Rsum n (fun x => f (x + m)%nat))%R.
Proof.
  intros m n f.
  induction n.
  simpl. 
  rewrite Nat.add_0_r. 
  lra.
  replace (m + S n0)%nat with (S (m + n0)) by lia. 
  rewrite 2 Rsum_extend.
  rewrite IHn.
  rewrite Nat.add_comm.
  lra.
Qed.

Lemma Rsum_twice : forall n f,
  Rsum (2 * n) f = (Rsum n f + Rsum n (fun x => f (x + n)%nat))%R.
Proof.
  intros n f. replace (2 * n)%nat with (n + n)%nat by lia. apply Rsum_plus_range.
Qed.

Lemma Rsum_plus: forall n f g,
  Rsum n (fun x => (f x + g x)%R) = ((Rsum n f) + (Rsum n g))%R.
Proof.
  intros n f g.
  induction n.
  simpl. lra.
  repeat rewrite Rsum_extend.
  rewrite IHn. lra.
Qed.

Lemma nested_Rsum : forall m n f,
  Rsum (2 ^ (m + n)) f 
    = Rsum (2 ^ m) (fun x => Rsum (2 ^ n) (fun y => f (x * 2 ^ n + y)%nat)).
Proof.
  intros m n.
  replace (2 ^ (m + n))%nat with (2 ^ n * 2 ^ m)%nat by unify_pows_two.
  induction m; intro f.
  simpl.
  rewrite Nat.mul_1_r.
  reflexivity.
  replace (2 ^ n * 2 ^ S m)%nat with (2 * (2 ^ n * 2 ^ m))%nat by unify_pows_two.
  replace (2 ^ S m)%nat with (2 * 2 ^ m)%nat by unify_pows_two.
  rewrite 2 Rsum_twice.
  rewrite 2 IHm.
  apply f_equal2; try reflexivity.
  apply Rsum_eq.
  intro x.
  apply Rsum_eq.
  intro y.
  apply f_equal.
  lia.
Qed.

Lemma divmod_decomp :
  forall x y z r,
    (r > 0)%nat ->
    (z < r)%nat ->
    (x = y * r + z <-> x / r = y /\ x mod r = z)%nat.
Proof.
  split; intros.
  - split. symmetry. apply Nat.div_unique with (r := z); try lia.
    symmetry. apply Nat.mod_unique with (q := y); try lia.
  - destruct H1.
    replace (y * r)%nat with (r * y)%nat by lia.
    rewrite <- H1, <- H2.
    apply Nat.div_mod.
    lia.
Qed.

Lemma split_basis_vector : forall m n x y,
  (x < 2 ^ m)%nat ->
  (y < 2 ^ n)%nat ->
  basis_vector (2 ^ (m + n)) (x * 2 ^ n + y) 
    = basis_vector (2 ^ m) x ⊗ basis_vector (2 ^ n) y.
Proof.
  intros m n x y Hx Hy.
  unfold kron, basis_vector.
  solve_matrix.
  bdestruct (y0 =? 0).
  - repeat rewrite andb_true_r.
    assert (2^n > 0)%nat.
    { assert (0 < 2^n)%nat by (apply pow_positive; lia). lia.
    }
    specialize (divmod_decomp x0 x y (2^n)%nat H0 Hy) as G.
    bdestruct (x0 =? x * 2 ^ n + y).
    + apply G in H1. destruct H1.
      rewrite H1, H2. do 2 rewrite Nat.eqb_refl. lca.
    + bdestruct (x0 / 2 ^ n =? x); bdestruct (x0 mod 2 ^ n =? y); try lca.
      assert ((x0 / 2 ^ n)%nat = x /\ x0 mod 2 ^ n = y) by easy.
      apply G in H4.
      easy.
  - repeat rewrite andb_false_r.
    lca.
Qed.

Lemma Rsum_0 : forall f n, (forall x : nat, f x = 0) -> Rsum n f = 0.
Proof.
  intros f n Hf. 
  induction n. reflexivity. 
  rewrite Rsum_extend, IHn, Hf. lra.
Qed.

Lemma rewrite_pr_outcome_sum : forall n k (c : base_ucom (n + k)) f,
  pr_outcome_sum (run c) (fun x => f (first_m n k x)) 
  = Rsum (2 ^ n) (fun x => ((if f x then 1 else 0) *
                         prob_partial_meas (basis_vector (2 ^ n) x) 
                           (UnitarySem.uc_eval c × basis_vector (2 ^ (n + k)) 0))%R).
Proof.
  intros n k c f.
  unfold pr_outcome_sum.
  unfold run at 1.
  rewrite map_length.
  rewrite vec_to_list_length.
  rewrite nested_Rsum.
  apply Rsum_eq_bounded.
  intros x Hx.
  destruct (f x) eqn:fx.
  rewrite Rmult_1_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. 
       rewrite simplify_first_m by assumption.
       rewrite fx.
       rewrite nth_run_probability_of_outcome.
       reflexivity.
       replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
       nia.
  }
  unfold prob_partial_meas.
  erewrite Rsum_eq_bounded.
  reflexivity.
  intros y Hy. 
  rewrite split_basis_vector by assumption.
  replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
  reflexivity.
  rewrite Rmult_0_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. rewrite simplify_first_m by assumption.
       rewrite fx. reflexivity. }
  apply Rsum_0.
  reflexivity.
Qed.

(* Main lemma #1 - the probability that shor_body returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.Shor_correct_full). *)
Lemma shor_body_returns_order : forall (a N : nat),
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  pr_outcome_sum 
      (run (to_base_ucom (n + k) circ))
      (fun x => OF_post a N (first_m n k x) n =? ord a N) 
    >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N Ha1 Ha2 n0 k0 circ.
  subst n0 k0 circ.
  remember (fun x => OF_post a N x (n N) =? ord a N) as f'.
  replace (fun x : nat => OF_post a N (first_m (n N) (k N) x) (n N) =? ord a N) 
    with (fun x : nat => f' (first_m (n N) (k N) x)).
  rewrite rewrite_pr_outcome_sum.
  specialize (Shor.Shor_correct_full a N Ha1 Ha2) as H1.
  specialize (shor_circuit_same a N) as H2.
  unfold prob_shor_outputs in H2.
  erewrite Rsum_eq.
  2: { intro i. rewrite H2. reflexivity. lia. }
  unfold probability_of_success_var in H1.
  unfold n in *.
  unfold k in *.
  unfold r_found in H1.
  subst f'.
  apply H1.
  subst f'.
  reflexivity.
Qed.

Lemma Rsum_scale : forall n f r,
  (r * Rsum n f = Rsum n (fun x => r * f x))%R.
Proof.
  intros n f r.
  induction n.
  simpl. lra.
  rewrite 2 Rsum_extend.
  rewrite <- IHn. lra.
Qed.

Lemma nth_repeat : forall n r i,
  (i < n)%nat -> nth i (repeat r n) 0 = r.
Proof.
  intros n r i Hi.
  rewrite nth_indep with (d':=r).
  clear Hi.
  gen i.
  induction n; intro i; simpl; destruct i; try reflexivity.
  apply IHn.
  rewrite repeat_length.
  assumption.
Qed.

Lemma pr_outcome_sum_cnttrue : forall l u f,
  (l < u)%nat ->
  pr_outcome_sum (uniform l u) f 
  = (INR (cnttrue (u - l) (fun x => f (l + x - 1)%nat)) / INR (u - l))%R.
Proof.
  intros l u f H.
  unfold uniform.
  rewrite pr_outcome_sum_append.
  rewrite pr_outcome_sum_repeat_false.
  rewrite Rplus_0_l.
  remember (u - l)%nat as n.
  assert (Hn:(n > 0)%nat) by lia.
  clear - Hn.
  unfold pr_outcome_sum.
  rewrite 2 repeat_length.
  erewrite Rsum_eq_bounded.
  2: { intros i Hi.
       replace  (if f (l + i)%nat then nth i (repeat (1 / INR n)%R n) 0 else 0) with
           ((1 / INR n)%R * (if f (l + i)%nat then 1 else 0))%R.
       reflexivity.
       destruct (f (l + i)%nat).
       rewrite nth_repeat by assumption.
       lra.
       lra. }
  rewrite <- Rsum_scale.
  replace (INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)) / INR n)%R with (1 / INR n * INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)))%R by lra.
  apply f_equal2; try reflexivity.
  clear Hn.
  induction n.
  reflexivity.
  rewrite Rsum_extend.
  simpl.
  rewrite IHn.
  replace (l + S n0 - 1)%nat with (l + n0)%nat by lia.
  destruct (f (l + n0)%nat); try lra. 
  rewrite S_O_plus_INR.
  simpl.
  reflexivity.
Qed.

Definition leads_to_factor N a := 
  nontrivgcd a N ||
  (nontrivgcd (a ^ ((ord a N) / 2)%nat - 1) N ||
   nontrivgcd (a ^ ((ord a N) / 2)%nat + 1) N).

(* Main lemma #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factoring_succeeds : forall N,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
   pr_outcome_sum
     (uniform 1 N)
     (fun x => leads_to_factor N x)
   >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  assert (H :( N - 1 <= 2 * cnttrue (N - 1) (leads_to_factor N))%nat).
  subst N.
  apply reduction_factor_order_finding; auto.
  assert (2 < N)%nat.
  subst N. 
  rewrite <- (Nat.mul_1_l 2).
  apply Nat.mul_lt_mono_nonneg; try lia.
  apply Nat.pow_gt_1; lia.
  rewrite pr_outcome_sum_cnttrue by lia.
  erewrite cnttrue_same.
  2 : { intros x Hx. replace (2 + x - 1)%nat with (x + 1)%nat by lia. reflexivity. }
  rewrite cnttrue_same with (g := leads_to_factor N).
  apply le_INR in H. rewrite mult_INR in H. replace (INR 2) with 2 in H by easy.
  unfold Rdiv.
  assert (0 < INR (N - 1)).
  { apply lt_0_INR. lia. }
  assert (0 < / INR (N - 1)).
  { apply Harmonic.INR_inv_pos. lia. }
  apply Rmult_le_compat_r with (r := (/ INR (N - 1))%R) in H; try lra.
  rewrite Rinv_r in H by lra.
  apply Rmult_le_compat_l with (r := 2%R) in H; try lra.
  intros. f_equal. lia.
Qed.

Definition is_a_factor x y := exists z, (1 < z < y)%nat /\ y = (z * x)%nat.

Lemma gcd_is_factor : forall x y, (1 < Nat.gcd x y < y)%nat -> is_a_factor (Nat.gcd x y) y.
Proof.
  intros x y H.
  unfold is_a_factor.
  specialize (Nat.gcd_divide_r x y) as G. destruct G.
  exists x0.
  split; try lia.
  split; nia.
Qed.

Lemma factor_returns_factor : forall a N r x,
  factor a N r = Some x -> is_a_factor x N.
Proof.
  intros a N r x H.
  unfold factor in H.
  remember (Nat.gcd (a ^ (r / 2) - 1) N) as k1.
  remember (Nat.gcd (a ^ (r / 2) + 1) N) as k2.
  bdestruct (1 <? k1); bdestruct (k1 <? N); 
    bdestruct (1 <? k2); bdestruct (k2 <? N); 
    simpl in H; inversion H; subst;
    apply gcd_is_factor; auto.
Qed.

Lemma sample_uniform_lb :
  forall m l r,
    0 <= r ->
    (m <= sample (repeat 0%R m ++ l) r)%nat.
Proof.
  induction m; intros.
  lia. simpl.
  destruct (Rlt_le_dec r 0). lra.
  specialize (IHm l r H).
  replace (r - 0)%R with r by lra.
  lia.
Qed.

Lemma sample_boom :
  forall l r,
    Forall (fun x => 0 <= x) l ->
    Rsum (length l) (fun i => nth i l 0) <= r ->
    sample l r = length l.
Proof.
  induction l; intros. easy.
  simpl. rewrite Rsum_list_extend in H0.
  inversion H; subst.
  specialize (Rsum_list_geq_0 l H4) as G.
  assert (Rsum (length l) (fun i : nat => nth i l 0) <= r - a)%R by lra.
  specialize (IHl (r - a)%R H4 H1) as T. rewrite T.
  destruct (Rlt_le_dec r a). lra. lia.
Qed.

Lemma sample_extend :
  forall l1 l2 r,
    Forall (fun x => 0 <= x) l1 ->
    Forall (fun x => 0 <= x) l2 ->
    Rsum (length l1) (fun i => nth i l1 0) <= r ->
    (sample (l1 ++ l2) r = (length l1) + sample l2 (r - Rsum (length l1) (fun i => nth i l1 0%R)))%nat.
Proof.
  induction l1; intros.
  - simpl. f_equal. lra.
Local Opaque Rsum.
  - rewrite Rsum_list_extend in *. simpl.
    inversion H; subst.
    specialize (Rsum_list_geq_0 l1 H5) as G.
    destruct (Rlt_le_dec r a); try lra.
    f_equal. rewrite IHl1; try easy; try lra.
    f_equal. f_equal. lra.
Qed.
Local Transparent Rsum.

Lemma sample_ub :
  forall l r, (sample l r <= length l)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma sample_ub_less :
  forall l r, 0 <= r < Rsum (length l) (fun i => nth i l 0) -> (sample l r < length l)%nat.
Proof.
  induction l; intros. simpl in H. lra.
  simpl. destruct (Rlt_le_dec r a). lia.
  apply lt_n_S. apply IHl. rewrite Rsum_list_extend in H. lra.
Qed.

Lemma sample_lb :
  forall l r, (0 <= sample l r)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma repeat_gt0 :
  forall m r, 0 <= r -> Forall (fun x => 0 <= x) (repeat r m).
Proof.
  induction m; intros. simpl. constructor.
  simpl. constructor. easy. apply IHm. easy.
Qed.

Lemma Rsum_repeat :
  forall m r, (Rsum (length (repeat r m)) (fun i => nth i (repeat r m) 0) = (INR m) * r)%R.
Proof.
  intros. induction m. simpl. lra.
  replace (repeat r (S m)) with (r :: repeat r m).
  rewrite Rsum_list_extend, IHm. rewrite S_INR. lra.
  easy.
Qed.

Lemma sample_uniform : forall l u r, (l < u)%nat -> 0 <= r < 1 -> (l <= sample (uniform l u) r < u)%nat.
Proof.
  intros. split.
  - unfold uniform. apply sample_uniform_lb. easy.
  - unfold uniform. rewrite sample_extend. rewrite repeat_length.
    assert (T: (forall a b c, a < c -> b < c - a -> a + b < c)%nat) by (intros; lia).
    apply T. easy.
    replace (u - l)%nat with (length (repeat (1 / INR (u - l))%R (u - l))) at 3 by apply repeat_length.
    apply sample_ub_less.
    replace l with (length (repeat 0 l)) at 1 2 by apply repeat_length.
    repeat rewrite Rsum_repeat.
    replace (INR (u - l) * (1 / INR (u - l)))%R with (INR (u - l) * / INR (u - l))%R by lra.
    rewrite Rinv_r. lra.
    apply not_0_INR. lia.
    apply repeat_gt0; lra.
    apply repeat_gt0. unfold Rdiv. rewrite Rmult_1_l.
    apply Rlt_le, Harmonic.INR_inv_pos. lia.
    rewrite Rsum_repeat. lra.
Qed.

Local Opaque uniform.
Lemma end_to_end_shors_correct : forall N rnds i niter x,
    (1 < N)%nat ->
    (forall m, 0 <= rnds m < 1) ->
    end_to_end_shors N rnds i niter = Some x ->
    is_a_factor x N.
Proof.
  intros N rnds i niter x H Hrnds H0.
  gen i.
  induction niter; intros.
  inversion H0.
  simpl in H0.
  bdestruct (Nat.gcd (sample (uniform 1 N) (rnds i)) N =? 1).
  destruct (shor_body (sample (uniform 1 N) (rnds i)) N (rnds (S i))) eqn:sb.
  inversion H0; subst.
  unfold shor_body in sb.
  apply factor_returns_factor in sb. auto.
  eapply IHniter. apply H0.
  inversion H0; subst.
  apply gcd_is_factor.
  specialize (sample_uniform 1 N (rnds i) H (Hrnds i)) as su.
  split.
  assert (0 < Nat.gcd (sample (uniform 1 N) (rnds i)) N)%nat.
  apply Natgcd_pos; lia.
  lia. 
  rewrite Nat.gcd_comm.
  assert (Nat.gcd N (sample (uniform 1 N) (rnds i)) <= sample (uniform 1 N) (rnds i))%nat.
  apply Misc.Nat_gcd_le_r.
  lia. lia.
Qed.

(* One possibility: represent multiple events using a list. *)
(* RNR: I like this better but I feel like it needs some notion of independence? *)
Inductive pr_Ps1 : (list (R -> Prop)) -> R -> Prop :=
| Singleton : forall P r, pr_P P r -> pr_Ps1 (P :: nil) r
| ConsCase : forall P r Ps rs, 
    pr_P P r ->
    pr_Ps1 Ps rs ->
    pr_Ps1 (P :: Ps) (r * rs)%R.

(* Another possibility: use a single predicate that takes a random stream as input. *)
(* RNR: What is P below? How does it connect to P1 and P2? Also, is it only for a function 
   defined on two inputs? *)
Inductive pr_Ps2 : ((nat -> R) -> Prop) -> R -> Prop :=
| From_pr_P : forall P1 P2 r1 r2 (P : (nat -> R) -> Prop),
    pr_P P1 r1 ->
    pr_P P2 r2 ->
    (forall rnds i j, i <> j -> P1 (rnds i) -> P2 (rnds j) -> P rnds) -> (* RNR: Explain? *)
    pr_Ps2 P (r1 * r2)%R
| Weaken : forall (P : (nat -> R) -> Prop) r r',
    pr_Ps2 P r ->
    (r' <= r)%R ->
    pr_Ps2 P r'.

Lemma pr_outcome_sum_geq_exists : forall l f r,
  distribution l ->
  pr_outcome_sum l f >= r ->
  exists r0, (r0 >= r)%R /\ pr_P (fun rnd => f (sample l rnd) = true) r0.
Proof.
  intros l f r  HlHr.
  exists (pr_outcome_sum l f).
  split; auto.
  apply pr_outcome_sum_eq_aux; auto.
Qed.

(* For one iterations of end_to_end_shors, the probability of success is
   (1 / 2) * (κ / INR (Nat.log2 N)^4). *)
Local Opaque pow leads_to_factor.
Lemma end_to_end_shors_succeeds_with_high_probability_1_iter : forall N (i : nat),
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  pr_Ps2
     (fun rnds => ssrbool.isSome (end_to_end_shors N rnds i 1) = true)
     ((1 / 2) * (κ / INR (Nat.log2 N)^4))%R.
Proof.
  intros N i HN1 HN2 HN3.
  specialize (shor_factoring_succeeds N) as H1.
  specialize shor_body_returns_order as H2.
  apply pr_outcome_sum_geq_exists in H1; auto.
  destruct H1 as [r1 [Hr1 H1]].
  (* how can we specialize "a" in H2?? *)
  eapply pr_outcome_sum_geq_exists in H2; auto.
  destruct H2 as [r2 [Hr2 H2]].
  apply Weaken with (r:=(r1 * r2)%R).
  eapply From_pr_P.
  apply H1.
  apply H2.
  (* something's gone horribly wrong here since we ended up with N=2 and a=1... *)
Admitted.

Import ListNotations.

Parameter Independent : list R -> Prop. 

(* This needs a base case too, I think I prefer pr_Ps1 *)
(* Maybe we want lists of Props and Rs though? *)
(*
Inductive joint_pr : (R -> Prop) -> (R -> Prop) -> R -> Prop:=
| j_pr :  forall P Q r1 r2,
    Independent r1 r2 ->
    pr_P P r1 ->
    pr_P Q r2 ->
    joint_pr P Q (r1 * r2).
 *)

Inductive joint_pr : list (R -> Prop) -> list R -> Prop:=
| pr1 : forall P r, pr_P P r -> joint_pr (P :: nil) [r]
| j_pr :  forall P Qs r1 rs,
    Independent (r1 :: rs) ->
    pr_P P r1 ->
    joint_pr Qs rs ->
    joint_pr (P :: Qs) ((r1 * (fold_left Rmult rs 1))%R :: nil).

(* Doesn't typecheck. Could arguably combine rnds into a single r by multiplying by 10. *)
Lemma end_to_end_shors_succeeds_with_high_probability_1_iter' : forall N (i : nat),
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  joint_pr
     ((fun rnds => ssrbool.isSome (end_to_end_shors N rnds i 1) = true) :: nil)
     (((1 / 2) * (κ / INR (Nat.log2 N)^4))%R :: nil).


(* For niter iterations, the probability of success is:
   1 - (the probability of failing in niter consecutive iterations).

   Do we want to (/ can we) prove this?  *)


(** TODO: facts about end_to_end_shors resources **)
