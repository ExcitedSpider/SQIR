Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

   Inputs:
     N = number to factor
     rnds = stream of random real values
     i = index into rnds
     niter = max number of iterations
   
   Output:
     None or Some x where x is a nontrivial factor of N.

   Algorithm: Up to a maximum number of iterations, select "a" uniformly from 
   [1,n-1] and
     1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
     2. Measure the first n qubits, resulting in the n-bit number x.
     3. Run continued fraction expansion (= OF_post) to get r, which is a 
        candidate for the order (ord a N).
     4. Use r to try to factor N.

  The probability of success (returning Some) and the resources (aka qubits and 
  gates) used is a function of N and niter (see proofs below). *)

(* Uniform sampling in the range [lower, upper) *)
Definition uniform (lower upper : nat) : list R :=
  repeat 0 lower ++ repeat (1/ INR (upper - lower))%R (upper - lower).

(* N   : number to factor
   out : outcome from sampling *)

(* When sampling from join l1 l2 where |l1|=n |l2|=m, 
   use the following functions to extract the result. *)
Definition fst_join (m x : nat) := (x / m)%nat.
Definition snd_join (m x : nat) := (x mod m)%nat.

Definition process N out :=
  let n := n N in
  let k := k N in
  let a := fst_join (2^(n + k)) out in
  let x := snd_join (2^(n + k)) out in
  (* try to factor *)
  if Nat.gcd a N =? 1%nat
  then factor a N (OF_post a N (first_k n (n + k) x) n)
  else Some (Nat.gcd a N).

(* N   : number to factor
   rnd : source of randomness for sampling *)
Definition shor_body N rnd :=
  let n := n N in
  let k := k N in
  (* create a distribution corresponding to choosing an 'a' and running
     Shor's circuit with this value 
     NOTE: we don't actually need to run the circuit in the case where a is not
     coprime to N, but it's easier to write the code this way *)
  let distr := join (uniform 1 N) 
                    (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
  (* sample from the distribution *)
  let out := sample distr rnd in
  (* try to factor *)
  process N out.

Definition end_to_end_shors N rnds :=
  iterate rnds (shor_body N).

(** Correctness properties for Shor's **)

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

Lemma nth_run_probability_of_outcome : forall n (c : base_ucom n) x,
  (x < 2 ^ n)%nat ->
  nth x (run c) 0 
    = probability_of_outcome 
        (basis_vector (2^n) x) 
        (UnitarySem.uc_eval c × basis_vector (2^n) 0).
Proof.
  intros n c x Hx.
  unfold run, probability_of_outcome.
  rewrite nth_indep with (d':=Cmod2 0).
  rewrite map_nth.
  remember (UnitarySem.uc_eval c × basis_vector (2 ^ n) 0) as ψ.
  rewrite nth_vec_to_list by assumption.
  rewrite (basis_vector_decomp ψ) at 2.
  rewrite Mmult_vsum_distr_l.
  symmetry.
  erewrite vsum_unique.
  2 : { exists x. split. assumption. 
        split.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_eq.
        reflexivity. assumption.
        intros y Hy Hxy.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_neq by auto.
        lma. }
  unfold Cmod, Cmod2.
  rewrite pow2_sqrt.
  unfold I, scale.
  simpl.
  lra.
  apply Rplus_le_le_0_compat; apply pow2_ge_0.
  subst. 
  apply WF_mult.
  apply WF_uc_eval.
  apply basis_vector_WF.
  apply pow_positive. lia.
  rewrite map_length.  
  rewrite vec_to_list_length.
  assumption.
Qed.

Lemma divmod_decomp :
  forall x y z r,
    (r > 0)%nat ->
    (z < r)%nat ->
    (x = y * r + z <-> x / r = y /\ x mod r = z)%nat.
Proof.
  split; intros.
  - split. symmetry. apply Nat.div_unique with (r := z); try lia.
    symmetry. apply Nat.mod_unique with (q := y); try lia.
  - destruct H1.
    replace (y * r)%nat with (r * y)%nat by lia.
    rewrite <- H1, <- H2.
    apply Nat.div_mod.
    lia.
Qed.

Lemma split_basis_vector : forall m n x y,
  (x < 2 ^ m)%nat ->
  (y < 2 ^ n)%nat ->
  basis_vector (2 ^ (m + n)) (x * 2 ^ n + y) 
    = basis_vector (2 ^ m) x ⊗ basis_vector (2 ^ n) y.
Proof.
  intros m n x y Hx Hy.
  unfold kron, basis_vector.
  solve_matrix.
  bdestruct (y0 =? 0).
  - repeat rewrite andb_true_r.
    assert (2^n > 0)%nat.
    { assert (0 < 2^n)%nat by (apply pow_positive; lia). lia.
    }
    specialize (divmod_decomp x0 x y (2^n)%nat H0 Hy) as G.
    bdestruct (x0 =? x * 2 ^ n + y).
    + apply G in H1. destruct H1.
      rewrite H1, H2. do 2 rewrite Nat.eqb_refl. lca.
    + bdestruct (x0 / 2 ^ n =? x); bdestruct (x0 mod 2 ^ n =? y); try lca.
      assert ((x0 / 2 ^ n)%nat = x /\ x0 mod 2 ^ n = y) by easy.
      apply G in H4.
      easy.
  - repeat rewrite andb_false_r.
    lca.
Qed.

Lemma rewrite_pr_outcome_sum : forall n k (c : base_ucom (n + k)) f,
  pr_outcome_sum (run c) (fun x => f (first_k n (n + k) x)) 
  = Rsum (2 ^ n) (fun x => ((if f x then 1 else 0) *
                         prob_partial_meas (basis_vector (2 ^ n) x) 
                           (UnitarySem.uc_eval c × basis_vector (2 ^ (n + k)) 0))%R).
Proof.
  intros n k c f.
  unfold pr_outcome_sum.
  unfold run at 1.
  rewrite map_length.
  rewrite vec_to_list_length.
  rewrite nested_Rsum.
  apply Rsum_eq_bounded.
  intros x Hx.
  destruct (f x) eqn:fx.
  rewrite Rmult_1_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. 
       rewrite Nat.mul_comm.
       rewrite simplify_first_k by assumption.
       rewrite fx.
       rewrite nth_run_probability_of_outcome.
       reflexivity.
       replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
       nia.
  }
  unfold prob_partial_meas.
  erewrite Rsum_eq_bounded.
  reflexivity.
  intros y Hy. 
  rewrite Nat.mul_comm.
  rewrite split_basis_vector by assumption.
  replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
  reflexivity.
  rewrite Rmult_0_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. rewrite Nat.mul_comm. rewrite simplify_first_k by assumption.
       rewrite fx. reflexivity. }
  apply Rsum_0.
  reflexivity.
Qed.

(* Main lemma #1 - the probability that shor_body returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.Shor_correct_full). *)
Lemma shor_body_returns_order : forall (a N : nat),
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  pr_outcome_sum 
      (run (to_base_ucom (n + k) circ))
      (fun x => OF_post a N (first_k n (n + k) x) n =? ord a N) 
    >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N Ha1 Ha2 n0 k0 circ.
  subst n0 k0 circ.
  remember (fun x => OF_post a N x (n N) =? ord a N) as f'.
  replace (fun x : nat => OF_post a N (first_k (n N) (n N + k N) x) (n N) =? ord a N) 
    with (fun x : nat => f' (first_k (n N) (n N + k N) x)).
  rewrite rewrite_pr_outcome_sum.
  specialize (Shor.Shor_correct_full a N Ha1 Ha2) as H1.
  specialize (shor_circuit_same a N) as H2.
  unfold prob_shor_outputs in H2.
  erewrite Rsum_eq.
  2: { intro i. rewrite H2. reflexivity. lia. }
  unfold probability_of_success_var in H1.
  unfold n in *.
  unfold k in *.
  unfold r_found in H1.
  subst f'.
  apply H1.
  subst f'.
  reflexivity.
Qed.

Lemma nth_repeat : forall n r i,
  (i < n)%nat -> nth i (repeat r n) 0 = r.
Proof.
  intros n r i Hi.
  rewrite nth_indep with (d':=r).
  clear Hi.
  gen i.
  induction n; intro i; simpl; destruct i; try reflexivity.
  apply IHn.
  rewrite repeat_length.
  assumption.
Qed.

Lemma pr_outcome_sum_cnttrue : forall l u f,
  (l < u)%nat ->
  pr_outcome_sum (uniform l u) f 
  = (INR (cnttrue (u - l) (fun x => f (l + x - 1)%nat)) / INR (u - l))%R.
Proof.
  intros l u f H.
  unfold uniform.
  rewrite pr_outcome_sum_append.
  rewrite pr_outcome_sum_repeat_false.
  rewrite Rplus_0_l.
  remember (u - l)%nat as n.
  assert (Hn:(n > 0)%nat) by lia.
  clear - Hn.
  unfold pr_outcome_sum.
  rewrite 2 repeat_length.
  erewrite Rsum_eq_bounded.
  2: { intros i Hi.
       replace  (if f (l + i)%nat then nth i (repeat (1 / INR n)%R n) 0 else 0) with
           ((1 / INR n)%R * (if f (l + i)%nat then 1 else 0))%R.
       reflexivity.
       destruct (f (l + i)%nat).
       rewrite nth_repeat by assumption.
       lra.
       lra. }
  rewrite <- Rsum_scale.
  replace (INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)) / INR n)%R with (1 / INR n * INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)))%R by lra.
  apply f_equal2; try reflexivity.
  clear Hn.
  induction n.
  reflexivity.
  rewrite Rsum_extend.
  simpl.
  rewrite IHn.
  replace (l + S n0 - 1)%nat with (l + n0)%nat by lia.
  destruct (f (l + n0)%nat); try lra. 
  rewrite S_O_plus_INR.
  simpl.
  reflexivity.
Qed.

Definition leads_to_factor N a := 
  nontrivgcd a N ||
  (nontrivgcd (a ^ ((ord a N) / 2)%nat - 1) N ||
   nontrivgcd (a ^ ((ord a N) / 2)%nat + 1) N).

(* Main lemma #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factoring_succeeds : forall N,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
   pr_outcome_sum
     (uniform 1 N)
     (fun x => leads_to_factor N x)
   >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  assert (H :( N - 1 <= 2 * cnttrue (N - 1) (leads_to_factor N))%nat).
  subst N.
  apply reduction_factor_order_finding; auto.
  assert (2 < N)%nat.
  subst N. 
  rewrite <- (Nat.mul_1_l 2).
  apply Nat.mul_lt_mono_nonneg; try lia.
  apply Nat.pow_gt_1; lia.
  rewrite pr_outcome_sum_cnttrue by lia.
  erewrite cnttrue_same.
  2 : { intros x Hx. replace (2 + x - 1)%nat with (x + 1)%nat by lia. reflexivity. }
  rewrite cnttrue_same with (g := leads_to_factor N).
  apply le_INR in H. rewrite mult_INR in H. replace (INR 2) with 2 in H by easy.
  unfold Rdiv.
  assert (0 < INR (N - 1)).
  { apply lt_0_INR. lia. }
  assert (0 < / INR (N - 1)).
  { apply Harmonic.INR_inv_pos. lia. }
  apply Rmult_le_compat_r with (r := (/ INR (N - 1))%R) in H; try lra.
  rewrite Rinv_r in H by lra.
  apply Rmult_le_compat_l with (r := 2%R) in H; try lra.
  intros. f_equal. lia.
Qed.

Definition is_a_factor x y := exists z, (1 < z < y)%nat /\ y = (z * x)%nat.

Lemma gcd_is_factor : forall x y, (1 < Nat.gcd x y < y)%nat -> is_a_factor (Nat.gcd x y) y.
Proof.
  intros x y H.
  unfold is_a_factor.
  specialize (Nat.gcd_divide_r x y) as G. destruct G.
  exists x0.
  split; try lia.
  split; nia.
Qed.

Lemma factor_returns_factor : forall a N r x,
  factor a N r = Some x -> is_a_factor x N.
Proof.
  intros a N r x H.
  unfold factor in H.
  remember (Nat.gcd (a ^ (r / 2) - 1) N) as k1.
  remember (Nat.gcd (a ^ (r / 2) + 1) N) as k2.
  bdestruct (1 <? k1); bdestruct (k1 <? N); 
    bdestruct (1 <? k2); bdestruct (k2 <? N); 
    simpl in H; inversion H; subst;
    apply gcd_is_factor; auto.
Qed.

Lemma sample_uniform_lb :
  forall m l r,
    0 <= r ->
    (m <= sample (repeat 0%R m ++ l) r)%nat.
Proof.
  induction m; intros.
  lia. simpl.
  destruct (Rlt_le_dec r 0). lra.
  specialize (IHm l r H).
  replace (r - 0)%R with r by lra.
  lia.
Qed.

Lemma sample_boom :
  forall l r,
    Forall (fun x => 0 <= x) l ->
    Rsum (length l) (fun i => nth i l 0) <= r ->
    sample l r = length l.
Proof.
  induction l; intros. easy.
  simpl. rewrite Rsum_list_extend in H0.
  inversion H; subst.
  specialize (Rsum_list_geq_0 l H4) as G.
  assert (Rsum (length l) (fun i : nat => nth i l 0) <= r - a)%R by lra.
  specialize (IHl (r - a)%R H4 H1) as T. rewrite T.
  destruct (Rlt_le_dec r a). lra. lia.
Qed.

Lemma sample_extend :
  forall l1 l2 r,
    Forall (fun x => 0 <= x) l1 ->
    Forall (fun x => 0 <= x) l2 ->
    Rsum (length l1) (fun i => nth i l1 0) <= r ->
    (sample (l1 ++ l2) r = (length l1) + sample l2 (r - Rsum (length l1) (fun i => nth i l1 0%R)))%nat.
Proof.
  induction l1; intros.
  - simpl. f_equal. lra.
Local Opaque Rsum.
  - rewrite Rsum_list_extend in *. simpl.
    inversion H; subst.
    specialize (Rsum_list_geq_0 l1 H5) as G.
    destruct (Rlt_le_dec r a); try lra.
    f_equal. rewrite IHl1; try easy; try lra.
    f_equal. f_equal. lra.
Qed.
Local Transparent Rsum.

Lemma sample_ub :
  forall l r, (sample l r <= length l)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma sample_ub_less :
  forall l r, 0 <= r < Rsum (length l) (fun i => nth i l 0) -> (sample l r < length l)%nat.
Proof.
  induction l; intros. simpl in H. lra.
  simpl. destruct (Rlt_le_dec r a). lia.
  apply lt_n_S. apply IHl. rewrite Rsum_list_extend in H. lra.
Qed.

Lemma sample_lb :
  forall l r, (0 <= sample l r)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma repeat_gt0 :
  forall m r, 0 <= r -> Forall (fun x => 0 <= x) (repeat r m).
Proof.
  induction m; intros. simpl. constructor.
  simpl. constructor. easy. apply IHm. easy.
Qed.

Lemma Rsum_repeat :
  forall m r, (Rsum (length (repeat r m)) (fun i => nth i (repeat r m) 0) = (INR m) * r)%R.
Proof.
  intros. induction m. simpl. lra.
  replace (repeat r (S m)) with (r :: repeat r m).
  rewrite Rsum_list_extend, IHm. rewrite S_INR. lra.
  easy.
Qed.

Lemma sample_uniform : forall l u r, (l < u)%nat -> 0 <= r < 1 -> (l <= sample (uniform l u) r < u)%nat.
Proof.
  intros. split.
  - unfold uniform. apply sample_uniform_lb. easy.
  - unfold uniform. rewrite sample_extend. rewrite repeat_length.
    assert (T: (forall a b c, a < c -> b < c - a -> a + b < c)%nat) by (intros; lia).
    apply T. easy.
    replace (u - l)%nat with (length (repeat (1 / INR (u - l))%R (u - l))) at 3 by apply repeat_length.
    apply sample_ub_less.
    replace l with (length (repeat 0 l)) at 1 2 by apply repeat_length.
    repeat rewrite Rsum_repeat.
    replace (INR (u - l) * (1 / INR (u - l)))%R with (INR (u - l) * / INR (u - l))%R by lra.
    rewrite Rinv_r. lra.
    apply not_0_INR. lia.
    apply repeat_gt0; lra.
    apply repeat_gt0. unfold Rdiv. rewrite Rmult_1_l.
    apply Rlt_le, Harmonic.INR_inv_pos. lia.
    rewrite Rsum_repeat. lra.
Qed.

(*Local Opaque uniform.*)

Lemma scale_zero :
  forall l, scale 0 l = repeat 0 (length l).
Proof.
  induction l; intros.
  - reflexivity.
  - simpl. rewrite IHl.
    replace (0 * a)%R with 0 by lra.
    reflexivity.
Qed.

Lemma join'_starting_zero :
  forall x l1 l2,
    join' (0 :: l1) l2 (S x) = repeat 0 (length (l2 O)) ++ join' l1 (fun i => l2 (S i)) x.
Proof.
  induction x; intros.
  - simpl. rewrite scale_zero.
    rewrite <- app_nil_end. reflexivity.
  - remember (S x) as Sx.
    simpl. rewrite IHx.
    subst. simpl.
    rewrite app_assoc. reflexivity.
Qed.

Lemma join_starting_zero :
  forall l1 l2,
    join (0 :: l1) l2 = repeat 0 (length (l2 O)) ++ join l1 (fun i => l2 (S i)).
Proof.
  intros. unfold join.
  rewrite <- join'_starting_zero. reflexivity.
Qed.

Lemma join'_length :
  forall x l1 l2 m,
    (forall k, (k < x)%nat -> length (l2 k) = m) ->
    (length (join' l1 l2 x) = x * m)%nat.
Proof.
  induction x; intros.
  - reflexivity.
  - simpl. rewrite app_length. rewrite IHx with (m := m).
    rewrite length_scale. rewrite H. lia. lia.
    intros. apply H. lia.
Qed.

Lemma sum_over_list_repeat :
  forall m x,
    (sum_over_list (repeat x m) = INR m * x)%R.
Proof.
  induction m; intros.
  - simpl. unfold sum_over_list. simpl. lra.
  - simpl. rewrite sum_over_list_cons. rewrite IHm.
    destruct m; simpl; lra.
Qed.

Lemma distribution_uniform :
  forall l r,
    (l < r)%nat ->
    distribution (uniform l r).
Proof.
  intros. split; unfold uniform.
  - apply Forall_app. split; apply repeat_gt0. lra.
    unfold Rdiv.
    assert (0 < / INR (r - l)).
    { apply Rinv_0_lt_compat. apply lt_0_INR. lia.
    }
    lra.
  - rewrite sum_over_list_append.
    do 2 rewrite sum_over_list_repeat.
    unfold Rdiv.
    replace (INR l * 0 + INR (r - l) * (1 * / INR (r - l)))%R with (INR (r - l) * / INR (r - l))%R by lra.
    rewrite <- Rinv_r_sym. easy.
    assert (0 < INR (r - l)) by (apply lt_0_INR; lia).
    lra.
Qed.

Lemma length_uniform :
  forall l r, (l <= r)%nat -> (length (uniform l r) = r)%nat.
Proof.
  intros. unfold uniform. rewrite app_length, repeat_length, repeat_length. lia.
Qed.

Local Opaque scale.
Lemma sample_join_uniform :
  forall (x m : nat) l2 rnd,
    (1 < x)%nat ->
    0 <= rnd < 1 ->
    (forall k, (k < x)%nat -> length (l2 k) = m) ->
    (forall k, (k < x)%nat -> distribution (l2 k)) ->
    (0 < m)%nat ->
    (1 <= fst_join m (sample (join (uniform 1 x) l2) rnd) < x)%nat.
Proof.
  intros. destruct x. lia. destruct x. lia.
  remember (repeat (1 / INR (S (S x) - 1))%R (S (S x) - 1)) as unm.
  assert ((join (uniform 1 (S (S x))) l2) = (repeat 0%R (length (l2 O)) ++ join unm (fun i : nat => l2 (S i)))).
  { unfold uniform. rewrite <- Hequnm.
    simpl. rewrite join_starting_zero. reflexivity.
  }
  assert (m <= (sample (join (uniform 1 (S (S x))) l2) rnd))%nat.
  { rewrite H4. rewrite H1 by lia. apply sample_uniform_lb. easy.
  }
  assert ((sample (join (uniform 1 (S (S x))) l2) rnd) < (S (S x)) * m)%nat.
  { replace ((S (S x)) * m)%nat with (length (join (uniform 1 (S (S x))) l2)).
    apply sample_ub_less.
    assert (distribution (join (uniform 1 (S (S x))) l2)).
    { apply distribution_join. apply distribution_uniform. lia.
      intros. apply H2. rewrite length_uniform in H6; lia.  
    }
    destruct H6. unfold sum_over_list in H7. rewrite H7. assumption.
    unfold join. rewrite join'_length with (m := m). rewrite length_uniform; lia.
    rewrite length_uniform by lia. apply H1. 
  }
  unfold fst_join. split.
  apply Nat.div_le_lower_bound; lia.
  apply Nat.div_lt_upper_bound; lia.
Qed.

Lemma length_run : forall n (c : base_ucom n),
  length (run c) = (2 ^ n)%nat. 
Proof.
  intros n c.
  unfold run.
  rewrite map_length.
  rewrite vec_to_list_length.
  reflexivity.
Qed.

Lemma pos_Cmod2_list :
  forall l, Forall (fun x => 0 <= x) (map Cmod2 l).
Proof.
  induction l; intros.
  - simpl. constructor.
  - simpl. constructor. apply Cmod2_ge_0. apply IHl.
Qed.

Lemma Cmod2_Cmod_sqr :
  forall c, (Cmod2 c = (Cmod c)^2)%R.
Proof.
  intros. unfold Cmod2, Cmod. rewrite R_sqrt.pow2_sqrt. lra.
  simpl. nra.
Qed.

Lemma sum_over_list_Cmod2_vec_to_list' :
  forall d x l,
    sum_over_list (map Cmod2 (@vec_to_list' x d l)) = Rsum d (fun i : nat => (Cmod (l (i + x - d)%nat 0%nat) ^ 2)%R).
Proof.
  induction d; intros.
  - unfold sum_over_list. reflexivity.
  - Local Opaque Rsum.
    simpl. rewrite sum_over_list_cons. rewrite IHd. simpl.
    rewrite Rsum_shift.
    replace (0 + x - S d)%nat with (x - S d)%nat by lia.
    rewrite Cmod2_Cmod_sqr. simpl.
    f_equal.
    Local Transparent Rsum.
Qed.

Lemma sum_over_list_Cmod2_vec_to_list :
  forall d (l : Vector d),
    sum_over_list (map Cmod2 (vec_to_list l)) = Rsum d (fun i : nat => (Cmod (l i 0%nat) ^ 2)%R).
Proof.
  intros. unfold vec_to_list.
  rewrite sum_over_list_Cmod2_vec_to_list'.
  apply Rsum_eq_bounded. intros.
  replace (i + d - d)%nat with i by lia.
  reflexivity.
Qed.

Lemma run_distribution :
  forall {dim} c,
    uc_well_typed c ->
    distribution (@run dim c).
Proof.
  intros. unfold run. split.
  - apply pos_Cmod2_list.
  - rewrite sum_over_list_Cmod2_vec_to_list.
    rewrite <- full_meas_equiv. rewrite Mmult_adjoint.
    rewrite <- Mmult_assoc. rewrite Mmult_assoc with (A := (basis_vector (2 ^ dim) 0) †).
    specialize (uc_eval_unitary dim c H) as G.
    destruct G. rewrite H1.
    restore_dims. rewrite Mmult_1_r.
    rewrite basis_vector_product_eq. reflexivity.
    apply pow_positive. lia.
    apply WF_adjoint. apply basis_vector_WF.
    apply pow_positive. lia.
Qed.

(* @Kesha: I am not familiar with uc_well_typed on this.
   May need help from you. *)
Lemma uc_well_typed_shor_circuit :
  forall a N,
    (a < N)%nat ->
    let n := n N in
    let k := k N in
    uc_well_typed (to_base_ucom (n + k) (shor_circuit a N)).
Proof.
Admitted.

Lemma end_to_end_shors_correct : forall N rnds x,
    (1 < N)%nat ->
    (Forall (fun x => 0 <= x < 1) rnds) ->
    end_to_end_shors N rnds = Some x ->
    is_a_factor x N.
Proof.
  intros N rnds x H Hrnds H0.
  unfold end_to_end_shors in H0.
  induction rnds as [ | rnd rnds]; intros.
  inversion H0.
  simpl in H0.
  destruct (shor_body N rnd) eqn:sb; auto.
  inversion H0; subst.
  unfold shor_body, process in sb.
  (* first, some cleanup *)
  remember (join (uniform 1 N)
                 (fun a : nat =>
                    run (to_base_ucom (n N + k N) (shor_circuit a N)))) as distr.
  remember (fst_join (2^(n N + k N)) (sample distr rnd)) as a.
  remember (snd_join (2^(n N + k N)) (sample distr rnd)) as o.
  (* now back to the proof... *)
  bdestruct (Nat.gcd a N =? 1).
  apply factor_returns_factor in sb. 
  auto.
  inversion sb.
  apply gcd_is_factor.
  assert (1 <= a < N)%nat.
  { rewrite Heqa, Heqdistr.
    inversion Hrnds.
    apply sample_join_uniform; try easy.
    intros. apply length_run.
    2: apply pow_positive; lia.
    intros. apply run_distribution.
    apply uc_well_typed_shor_circuit. lia.
  }
  assert (0 < Nat.gcd a N)%nat.
  apply Natgcd_pos; lia.
  assert (Nat.gcd a N <= a)%nat.
  rewrite Nat.gcd_comm.
  apply Misc.Nat_gcd_le_r.
  lia. 
  lia.
  inversion Hrnds. apply IHrnds; assumption.
Qed.

Lemma geq_exists : forall a b,
  a >= b -> exists c, a = c /\ c >= b.
Proof. intros a b H. exists a. split; auto. Qed.

Lemma fst_join_first_k :
  forall p q x, first_k p (p + q)%nat x = fst_join (2^q)%nat x.
Proof.
  intros. unfold first_k, fst_join. f_equal. f_equal. lia.
Qed.

Lemma snd_join_last_k :
  forall p q x, last_k q (p + q)%nat x = snd_join (2^q)%nat x.
Proof.
  intros.
  assert (0 < 2^q)%nat by (apply pow_positive; lia).
  unfold last_k, first_k, snd_join. rewrite Nat.mod_eq by lia.
  replace (p + q - (p + q - q))%nat with q by lia.
  f_equal. lia.
Qed.

Lemma κn4in01 :
  forall x,
    (1 <= x)%nat ->
    (0 < κ / (INR x ^ 4) < 1)%R.
Proof.
  intros. specialize (le_INR 1 x H) as G. simpl in G.
  specialize κgt0 as T.
  split; unfold Rdiv.
  - assert (0 < / (INR x ^ 4)).
    { apply Rinv_0_lt_compat. 
      apply pow_lt. lra.
    }
    nra.
  - assert (1 <= x ^ 4)%nat.
    { replace 1%nat with (x ^ 0)%nat at 1 by reflexivity.
      apply Nat.pow_le_mono_r; lia.
    }
    assert (/ (INR x ^ 4) <= / 1).
    { apply Rinv_le_contravar. lra. apply le_INR in H0.
      simpl in H0. repeat rewrite mult_INR in H0. simpl in H0. simpl. lra.
    }
    rewrite Rinv_1 in H1.
    assert (0 < / (INR x ^ 4)).
    { apply Rinv_0_lt_compat. apply le_INR in H0.
      simpl in H0. repeat rewrite mult_INR in H0. simpl in H0. simpl. lra.
    }
    specialize κlt1 as T'.
    nra.
Qed.

Lemma shor_body_succeeds_with_high_probability' : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    let un_sz := Nat.log2_up (N - 1) in
    let f1 a := leads_to_factor N a in
    let f2 a x := (OF_post a N (first_k n (n + k) x) n =? ord a N) ||
                  negb (Nat.gcd a N =? 1) in
    pr_outcome_sum distr
      (fun z => let x := first_k un_sz (un_sz + (n + k)) z in
             let y := last_k (n + k) (un_sz + (n + k)) z in
             f1 x && f2 x y)
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion H0. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (H1 p O Hp2). simpl in H1. lia. lia.
  }
  assert (ILog : (1 <= Nat.log2 N)%nat).
  { specialize (Nat.log2_pos N) as G. lia.
  }
  specialize (κn4in01 (Nat.log2 N) ILog) as G.
  apply pr_outcome_sum_join_geq.
  apply distribution_uniform.
  apply H1N.
  lra.
  apply shor_factoring_succeeds; auto.
  intros i Hi.
  split.
  apply length_run.
  subst f2.
  assert (Hdist : distribution (run (to_base_ucom (n0 + k0) (shor_circuit i N)))).
  { apply run_distribution.
    apply uc_well_typed_shor_circuit.
    rewrite length_uniform in Hi.
    lia.
    lia.
  }
  bdestruct (Nat.gcd i N =? 1).
  eapply Rge_trans.
  apply Rle_ge.
  apply pr_outcome_sum_orb.
  destruct Hdist as [Hdist _]; auto.
  apply shor_body_returns_order.
  split.
  destruct i. simpl in H2. lia. lia.
  rewrite length_uniform in Hi. lia. lia.
  unfold coprime.
  assumption.
  rewrite pr_outcome_sum_true.
  destruct Hdist as [_ Hdist].
  rewrite Hdist.
  lra.
  intros j Hj.
  bdestructΩ (Nat.gcd i N =? 1).
Qed.

Lemma shor_body_succeeds_with_high_probability : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    pr_outcome_sum distr (fun x => negb (isNone (process N x)))
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros N HN1 HN2 HN3 n k distr.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion HN2. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (HN3 p O Hp2). simpl in HN3. lia. lia.
  }
  assert (Hdist: distribution distr).
  subst distr. 
  apply distribution_join.
  apply distribution_uniform.
  lia.
  intros i Hi.
  apply run_distribution.
  apply uc_well_typed_shor_circuit.
  rewrite length_uniform in Hi.
  lia.
  lia.
  apply Rle_ge.
  eapply Rle_trans.
  apply Rge_le.
  apply shor_body_succeeds_with_high_probability'; auto.
  apply pr_outcome_sum_implies.
  destruct Hdist as [Hdist _]; auto.
  simpl.
  intros x H.
  unfold process.
  subst n k.
  rewrite fst_join_first_k in H.
  rewrite snd_join_last_k in H.
  remember (fst_join (2 ^ (n N + k N)) x) as a.
  remember (snd_join (2 ^ (n N + k N)) x) as y.
  clear - H.
  destruct (Nat.gcd a N =? 1) eqn:E; auto.
  apply beq_nat_true in E.
  apply andb_prop in H as [H1 H2].
  simpl in H2. rewrite orb_false_r in H2.
  apply beq_nat_true in H2. rewrite H2.
  unfold factor.
  unfold leads_to_factor in H1.
  remember (a ^ (ord a N / 2) + 1)%nat as ap1.
  remember (a ^ (ord a N / 2) - 1)%nat as am1.
  replace ((1 <? Nat.gcd am1 N) && (Nat.gcd am1 N <? N)) with (nontrivgcd am1 N) by (unfold nontrivgcd; reflexivity).
  replace ((1 <? Nat.gcd ap1 N) && (Nat.gcd ap1 N <? N)) with (nontrivgcd ap1 N) by (unfold nontrivgcd; reflexivity).
  destruct (nontrivgcd am1 N). easy.
  destruct (nontrivgcd ap1 N). easy.
  simpl in H1. rewrite orb_false_r in H1.
  unfold nontrivgcd, nontriv in H1. rewrite E in H1. simpl in H1. easy.
Qed.

Lemma pr_outcome_sum_neg' :
  forall distr f,
    (pr_outcome_sum distr (fun x => negb (f x)) = sum_over_list distr - pr_outcome_sum distr f)%R.
Proof.
  induction distr; intros.
  - unfold sum_over_list, pr_outcome_sum. simpl. lra.
  - do 2 rewrite pr_outcome_sum_extend'.
    rewrite IHdistr.
    rewrite sum_over_list_cons.
    destruct (f 0%nat); simpl; lra.
Qed.

Lemma pr_outcome_sum_neg :
  forall distr f,
    (pr_outcome_sum distr f = sum_over_list distr - pr_outcome_sum distr (fun x => negb (f x)))%R.
Proof.
  intros.
  specialize (pr_outcome_sum_neg' distr f) as G.
  lra.
Qed.

Lemma shor_body_fails_with_low_probability : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    pr_outcome_sum distr (fun x => isNone (process N x))
      <= 1 - (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion H0. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (H1 p O Hp2). simpl in H1. lia. lia.
  }
  rewrite pr_outcome_sum_neg.
  specialize (shor_body_succeeds_with_high_probability N H H0 H1) as G.
  assert (distribution distr).
  { apply distribution_join.
    apply distribution_uniform.
    lia.
    intros.
    apply run_distribution.
    apply uc_well_typed_shor_circuit.
    rewrite length_uniform in H2. lia.
    lia.
  }
  destruct H2. rewrite H3.
  assert (forall r1 r2 r3, r2 >= r3 -> r1 - r2 <= r1 - r3)%R by (intros; lra).
  apply H4. apply G.
Qed.

Lemma pr_outcome_sum_ge_0 :
  forall l f, Forall (fun x => 0 <= x) l -> 0 <= pr_outcome_sum l f.
Proof.
  induction l; intros.
  - unfold pr_outcome_sum. simpl. lra.
  - inversion H; subst. unfold pr_outcome_sum.
    replace (length (a :: l)) with (S (length l)) by easy.
    rewrite Rsum_shift. simpl.
    specialize (IHl (fun x => f (S x)) H3).
    unfold pr_outcome_sum in IHl.
    destruct (f 0%nat); lra.
Qed.

Lemma pr_outcome_sum_leq_exists : forall l f r,
  distribution l ->
  pr_outcome_sum l f <= r ->
  exists r0, (0 <= r0 <= r)%R /\ pr_P (fun rnd => f (sample l rnd) = true) r0.
Proof.
  intros l f r  HlHr.
  exists (pr_outcome_sum l f).
  split; auto.
  split. apply pr_outcome_sum_ge_0. apply HlHr. auto.
  apply pr_outcome_sum_eq_aux; auto.
Qed.

(* For n iterations of end_to_end_shors, the probability of success is
   1 - (1 - ((1 / 2) * (κ / INR (Nat.log2 N)^4))^n). *)
Local Opaque pow leads_to_factor.
Lemma end_to_end_shors_fails_with_low_probability : forall N niter r,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  pr_Ps (fun rnds => isNone (end_to_end_shors N rnds) = true) niter r ->
  (r <= (1 - (1 / 2) * (κ / INR (Nat.log2 N)^4))^niter)%R.
Proof.
  intros N niter r HN1 HN2 HN3 H.
  assert (H1N : (1 < N)%nat).
  { destruct N. inversion HN2. lia.
    destruct N. destruct (infinitely_many_primes 1%nat) as [p [Hp1 Hp2]].
    specialize (HN3 p O Hp2). simpl in HN3. lia. lia.
  }
  unfold end_to_end_shors in H.
  specialize (shor_body_fails_with_low_probability N HN1 HN2 HN3) as Hbody.
  apply pr_outcome_sum_leq_exists in Hbody.
  destruct Hbody as [r0 [? ?]].
  apply pr_iterate_None with (n := niter) in H1.
  eapply pr_Ps_unique in H. 
  2: apply H1.
  subst r.
  remember (1 / 2 * (κ / INR (Nat.log2 N) ^ 4)) as β.
  clear H1.
  apply pow_incr.
  assumption.
  apply distribution_join.
  apply distribution_uniform.
  lia.
  intros i Hi.
  apply run_distribution.
  apply uc_well_typed_shor_circuit.
  rewrite length_uniform in Hi.
  auto.
  lia.
Qed.


(** TODO @Yuxiang: facts about end_to_end_shors resources **)
