Require Import Shor.
Require Import euler.Primes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.

(* The definitions and proofs in this file are largely wrappers around definitions
   and proofs in other files. At some point, I might clean up the code in the 
   other files directly so this file won't be necessary. -KH *)


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* Shor circuit *)
(* RNR: Why is this necessary? *)
(* KH: not necessary :) *)
Definition shor_circuit (a N : nat) := AltShor.shor_circuit a N. 

(* Continued fraction expansion *)
Definition cont_frac_exp (a N o : nat) := Shor.OF_post a N o (n N).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(** Old attempt: **)

(* End-to-end definition of Shor's algorithm.

1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
2. Measure the first n qubits, resulting in the n-bit number x.
3. Run cont. frac. expansion to get r, which is a candidate for the order (ord a N).
4. Use r to try to factor N.

  The probability that cont_frac_exp correctly returns (ord a N) is at least
  1/polylog(N), as shown in shor_OF_correct. The probability that factor
  returns a factor of N (given the correct order) is at least 1/2, as shown
  in shor_factor_correct. *)
Definition end_to_end_shors a N rnd :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd in
  let r := cont_frac_exp a N x in
  factor a N r.

(** New (more accurate?) attempt: **)

(* Uniform sampling from 0 to n *)
(* TODO: actually, we only want [2, n-1] *)
Definition uniform (n : nat) (rnd : R) : nat :=
  sample (repeat (1/ INR n)%R n) rnd. 

Definition OF_body a N rnd :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd in
  let r := cont_frac_exp a N x in
  if modexp a r N =? 1
  then Some r else None.

Fixpoint find_order a N rnds i niter :=
  match niter with
  | 0 => None
  | S niter' => 
      match OF_body a N (rnds i) with
      | None => find_order a N rnds (S i) niter'
      | Some r => Some r
      end
  end.

Definition shor_body a N rnds i niter :=
  match find_order a N rnds i niter with
  | Some r => factor a N r
  | None => None
  end.

(* N = number to factor
   rnds = random stream
   i = index into the random stream
   niter = max number of iterations for the main Shor loop
   niterOF = max number of iterations for the order finding inner loop *)
Fixpoint end_to_end_shors2 N (rnds : nat -> R) i niter niterOF :=
  match niter with
  | 0 => None
  | S niter' =>
      let a := uniform N (rnds i) in
      if Nat.gcd a N =? 1%nat
      then 
        match shor_body a N rnds i niterOF with
        | None => end_to_end_shors2 N rnds (S i) niter' niterOF
        | Some f => Some f
        end
      else (* lucky case: "a" gives us factor directly *)
        Some (Nat.gcd a N)
  end.
(* -> the probability of success and resources used will be some function
      of N, niter, and niterOF. *)

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.




(** * Section on Prime Numbers *)

(* TODO: @Yuxiang, move to Euler repo & change the defn of prime there *)

Section Primes.

Require Import Wf.

Local Open Scope nat_scope.

(* TODO: Develop this, use Prime as main definition of primality.
   Prime shouldn't be defined in terms of a primality checker. -RNR

Definition divides (a b : nat) := exists n, a * n = b. 

Infix "|" := divides (at level 30).

Definition Prime (p : nat) := p > 1 /\ forall a, a | p -> a = 1 \/ a = p.

Definition Composite (n : nat) := exists a b, a > 1 /\ b > 1 /\ a * b = n.
 *)

Lemma NatOdd2x :
  forall x, ~ Nat.Odd (x * 2).
Proof.
  induction x. simpl. intro. inversion H. lia.
  intro. simpl in *. rewrite Nat.Odd_succ_succ in H. easy.
Qed.

Lemma coprime_list_prod :
  forall p l f,
    (forall q, In q l -> Nat.gcd p q = 1) ->
    Nat.gcd p (fold_left Nat.mul (map (fun x : nat => x ^ f x) l) 1) = 1.
Proof.
  intros. induction l.
  simpl. apply Nat.gcd_1_r.
  simpl. replace (a ^ f a + 0) with (1 * (a ^ f a)) by lia.
  rewrite <- Misc.List_fold_left_mul_assoc.
  apply Misc.Nat_gcd_1_mul_r.
  apply IHl. intros. apply H. apply in_cons. easy.
  apply pow_coprime. apply H. constructor. easy.
Qed.

Lemma simplify_primality : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k) ->
    (exists p k q, (k <> 0) /\ prime p /\ (p > 2) /\ (q > 2) /\ coprime (p ^ k) q /\ N = p ^ k * q)%nat.
Proof.
  intros.
  assert (GN : N > 1).
  { destruct H0. specialize (H1 2 0 eq_refl). simpl in *. lia. }  
  destruct (prime_divisors N) as [| p [| q l]] eqn:E.
  - apply Primisc.prime_divisors_nil_iff in E. lia.
  - assert (Hp: In p (prime_divisors N)) by (rewrite E; constructor; easy).
    apply Prod.prime_divisors_aux in Hp. destruct Hp as [Hp Hpn].
    assert (HN0: N <> 0) by lia.
    specialize (Prod.prime_divisor_pow_prod N HN0) as G.
    rewrite E in G. simpl in G.    
    specialize (H1 p (Prod.pow_in_n N p) Hp).
    remember (p ^ Prod.pow_in_n N p) as pk.
    rewrite <- G in H1. lia.
  - assert (Hp: In p (prime_divisors N)) by (rewrite E; constructor; easy).
    assert (Hq: In q (prime_divisors N)) by (rewrite E; constructor; constructor; easy).
    assert (Hp': In p (prime_decomp N)) by (apply Primisc.prime_divisors_decomp; easy).
    assert (Hq': In q (prime_decomp N)) by (apply Primisc.prime_divisors_decomp; easy).
    apply in_prime_decomp_divide in Hp'. apply in_prime_decomp_divide in Hq'.
    apply Prod.prime_divisors_aux in Hp. destruct Hp as [Hp Hpn].
    apply Prod.prime_divisors_aux in Hq. destruct Hq as [Hq Hqn].
    remember (q :: l) as lq.
    assert (HN0: N <> 0) by lia.
    specialize (Prod.prime_divisor_pow_prod N HN0) as G.
    rewrite E in G. simpl in G.
    replace (p ^ Prod.pow_in_n N p + 0) with (1 * (p ^ Prod.pow_in_n N p)) in G by lia.
    rewrite <- Misc.List_fold_left_mul_assoc in G.
    remember (Prod.prod (map (fun x : nat => x ^ Prod.pow_in_n N x) lq)) as Plq.
    exists p, (Prod.pow_in_n N p), Plq.
    split. lia. split. easy.
    split. assert (2 <= p) by (apply prime_ge_2; easy).
    bdestruct (2 =? p). rewrite <- H3 in Hp'. destruct Hp'. rewrite H4 in H0. apply NatOdd2x in H0. easy. lia.
    assert (HeqPlq' := HeqPlq).
    simpl in HeqPlq'. rewrite <- HeqPlq' in G.
    rewrite Heqlq in HeqPlq.
    rewrite map_cons, Prod.prod_extend in HeqPlq.
    split.
    bdestruct (Plq =? 0). rewrite H2 in G. lia.
    bdestruct (Plq =? 1).
    assert (2 <= q) by (apply prime_ge_2; easy).
    assert (Prod.pow_in_n N q < q ^ Prod.pow_in_n N q) by (apply Nat.pow_gt_lin_r; lia).
    assert (2 <= q ^ Prod.pow_in_n N q) by lia.
    destruct (Prod.prod (map (fun x : nat => x ^ Prod.pow_in_n N x) l)); lia.
    bdestruct (Plq =? 2). rewrite H4 in G. rewrite <- G in H0. rewrite Nat.mul_comm in H0. apply NatOdd2x in H0. easy.
    lia.
    split. unfold coprime. apply Prod.Nat_gcd_1_pow_l.
    rewrite HeqPlq'. apply coprime_list_prod.
    intros. assert (In q0 (prime_divisors N)) by (rewrite E; apply in_cons; easy).
    assert (p <> q0).
    { specialize (Prod.prime_divisors_distinct N) as T. rewrite E in T.
      inversion T. intro. subst. easy.
    } 
    apply Prod.prime_divisors_aux in H3. destruct H3 as [Hq0 Hq0n].
    apply eq_primes_gcd_1; easy.
    lia.
Qed.

End Primes.




(** Correctness properties for Shor's **)

(* Fact #1 - the probability that run_circuit returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.v). *)
Lemma shor_OF_correct : forall (a N : nat) pr,
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  max_interval 
    (fun rnd => cont_frac_exp a N 
               (run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd) 
             = ord a N) 
    pr ->
  pr >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N pr Ha1 Ha2 n0 k0 circ H.
  subst n0 k0 circ.
  (* H is not in the right form for pr_run_outcome_eq, but once we apply 
     that we should be able to use Shor.Shor_correct_full. We'll also need
     lemmas that relate pr_outcome and pr_outcome_partial to our 
     probability_of_outcome and prob_partial_meas. *)
Admitted.

Definition k1 a N : nat := ((ord a N) / 2) + 1.
Definition k2 a N : nat := ((ord a N) / 2) - 1.
Definition nontrivial_factor a b := 
  ((a < b) /\ (1 < Nat.gcd a b) /\ (Nat.gcd a b < b))%nat.

(* Fact #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factor_correct : forall N r,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  let is_a_factor a x := nontrivial_factor (a ^ k1 a N) N \/
                         nontrivial_factor (a ^ k2 a N) N in
   (* TODO: this should be the general version of max_interval *)
   max_interval
     (fun rnd => let a := uniform N rnd in
              coprime a N -> is_a_factor a N )
    r ->
  r >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  specialize (reduction_factor_order_finding p k q H0 H1 H3 H4 H5) as H.
  (* we should be able to use H somehow... *)
Admitted.

(* need some relationship between (cnttrue n P) and 
   (max_interval (fun rnd => P (unfiform n rnd))

...

the max_interval term should end up being (cnttrue n P) / n

 *)

(* Some generalization of max_interval to account for a random stream.
   Using randomness at different positions in the stream should lead to
   independent outcomes *)
Parameter max_interval_s : ((nat -> R) -> Prop) -> R -> Prop.

(* In the end we should have something like this... *)
Lemma end_to_end_shors_correct : forall N niter niterOF pr,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  max_interval_s
     (fun rnds => match end_to_end_shors2 N rnds O niter niterOF with
               | Some _ => True | _ => False end )
     pr ->
  pr >= (1 / 2) ^ niter * (κ / INR (Nat.log2 N)^4) ^ niterOF.
Proof.
Admitted.
