Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.

(* The definitions and proofs in this file are largely wrappers around definitions
   and proofs in other files. At some point, I might clean up the code in the 
   other files directly so this file won't be necessary. -KH *)


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* Shor circuit *)
(* RNR: Why is this necessary? *)
(* KH: not necessary :) *)
Definition shor_circuit (a N : nat) := AltShor.shor_circuit a N. 

(* Continued fraction expansion *)
Definition cont_frac_exp (a N o : nat) := Shor.OF_post a N o (n N).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(** Old attempt: **)

(* End-to-end definition of Shor's algorithm.

1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
2. Measure the first n qubits, resulting in the n-bit number x.
3. Run cont. frac. expansion to get r, which is a candidate for the order (ord a N).
4. Use r to try to factor N.

  The probability that cont_frac_exp correctly returns (ord a N) is at least
  1/polylog(N), as shown in shor_OF_correct. The probability that factor
  returns a factor of N (given the correct order) is at least 1/2, as shown
  in shor_factor_correct. *)
Definition end_to_end_shors a N rnd :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd in
  let r := cont_frac_exp a N x in
  factor a N r.

(** New (more accurate?) attempt: **)

(* Uniform sampling from 0 to n *)
(* TODO: actually, we only want [2, n-1] *)
Definition uniform (n : nat) (rnd : R) : nat :=
  sample (repeat (1/ INR n)%R n) rnd. 

Definition shor_body a N rnd := (* same as end_to_end_shors *)
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd in
  let r := cont_frac_exp a N x in
  factor a N r.

(* N = number to factor
   rnds = random stream
   i = index into the random stream
   niter = max number of iterations *)
Fixpoint end_to_end_shors2 N (rnds : nat -> R) i niter :=
  match niter with
  | 0 => None
  | S niter' =>
      let a := uniform N (rnds i) in
      if Nat.gcd a N =? 1%nat
      then 
        match shor_body a N (rnds (S i)) with
        | None => end_to_end_shors2 N rnds (S (S i)) niter'
        | Some f => Some f
        end
      else (* lucky case: "a" gives us factor directly *)
        Some (Nat.gcd a N)
  end.
(* -> the probability of success and resources used will be some function
      of N and niter. *)

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

(** Correctness properties for Shor's **)

(* Fact #1 - the probability that run_circuit returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.v). *)
Lemma shor_OF_correct : forall (a N : nat) pr,
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  max_interval (* urg this is _disjoint too *)
    (fun rnd => cont_frac_exp a N 
               (run_and_measure_partial n k (to_base_ucom (n + k) circ) rnd) 
             = ord a N) 
    pr ->
  pr >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N pr Ha1 Ha2 n0 k0 circ H.
  subst n0 k0 circ.
  (* H is not in the right form for pr_run_outcome_eq
     -- is cont_frac_exp unique? --
     but once we apply pr_run_outcome_eq, we should be able to use 
     Shor.Shor_correct_full. We'll also need lemmas that relate pr_outcome 
     and pr_outcome_partial to our probability_of_outcome and prob_partial_meas. *)
Admitted.

Definition k1 a N : nat := ((ord a N) / 2) + 1.
Definition k2 a N : nat := ((ord a N) / 2) - 1.
Definition nontrivial_factor a b := 
  ((1 < Nat.gcd a b) /\ (Nat.gcd a b < b))%nat.

(* Fact #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factor_correct : forall N r,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  let is_a_factor a x := nontrivial_factor a N \/
                         nontrivial_factor (a ^ k1 a N) N \/
                         nontrivial_factor (a ^ k2 a N) N in
   (* TODO: this should be the general version of max_interval *)
   max_interval_disjoint
     (fun rnd => let a := uniform N rnd in
              is_a_factor a N )
    0 1 r ->
  r >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  specialize (reduction_factor_order_finding p k q H0 H1 H3 H4 H5) as H.
Print Shor_correct_full.
  (* we should be able to use H somehow... *)
Admitted.

(* need some relationship between (cnttrue n P) and 
   (max_interval (fun rnd => P (uniform n rnd))

...

the max_interval_disjoint term should end up being (cnttrue n P) / n

 *)

(*
Lemma cnttrue_max_interval_disjoint : forall n P f,
  reflect P f ->
  max_interval_disjoint (fun rnd => P (uniform n rnd)) (cnttrue n f / n).
Proof.
Admitted.

(* Some generalization of max_interval to account for a random stream.
   Using randomness at different positions in the stream should lead to
   independent outcomes *)
Parameter max_interval_s : ((nat -> R) -> Prop) -> R -> Prop.

(* In the end we should have something like this... *)
Lemma end_to_end_shors_correct : forall N niter pr,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  max_interval_s
     (fun rnds => ssrbool.isSome (end_to_end_shors2 N rnds O niter))
     pr ->
  pr >= (1 / 2) ^ niter * (κ / INR (Nat.log2 N)^4).
Proof.
Admitted.

(* also: if e2esh returns Some x then x is a factor of N *)
*)
