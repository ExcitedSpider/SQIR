Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.

(* The definitions and proofs in this file are largely wrappers around definitions
   and proofs in other files. At some point, I might clean up the code in the 
   other files directly so this file won't be necessary. -KH *)


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

   Inputs:
     N = number to factor
     rnds = stream of random real values
     i = index into rnds
     niter = max number of iterations
   
   Output:
     None or Some x where x is a nontrivial factor of N.

   Algorithm: Up to a maximum number of iterations, select "a" uniformly from 
   [2,n-1] and
     1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
     2. Measure the first n qubits, resulting in the n-bit number x.
     3. Run continued fraction expansion (= OF_post) to get r, which is a 
        candidate for the order (ord a N).
     4. Use r to try to factor N.

  The probability of success (returning Some) and the resources (aka qubits and 
  gates) used is a function of N and niter (see proofs below). *)
(* @Yuxiang: does the new definition of end_to_end_shors look correct? *)

(* Uniform sampling in the range [lower, upper) *)
Definition uniform (lower upper : nat) : list R :=
  repeat 0 lower ++ repeat (1/ INR (upper - lower))%R (upper - lower).

Definition shor_body a N rnd :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_and_measure (to_base_ucom (n + k) circ) rnd in
  let r := OF_post a N x n in
  factor a N r.

Fixpoint end_to_end_shors N (rnds : nat -> R) i niter :=
  match niter with
  | 0 => None
  | S niter' =>
      let a := sample (uniform 2 N) (rnds i) in
      if Nat.gcd a N =? 1%nat
      then 
        match shor_body a N (rnds (S i)) with
        | None => end_to_end_shors N rnds (S (S i)) niter'
        | Some f => Some f
        end
      else (* lucky case: "a" gives us factor directly *)
        Some (Nat.gcd a N)
  end.

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

(** Correctness properties for Shor's **)

(* Fact #1 - the probability that shor_body returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.Shor_correct_full). *)
Lemma shor_body_returns_order : forall (a N : nat),
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  pr_outcome_sum (* or r_interval *)
      (run (to_base_ucom (n + k) circ))
      (fun x => OF_post a N x n =? ord a N) 
    >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N Ha1 Ha2 n0 k0 circ.
  subst n0 k0 circ.
  (* Should be easy to prove that pr_outcome_sum corresponds to our defn of
     prob_partial_meas, which should mean that we can complete the proof with
     Shor.Shor_correct_full. *)
Admitted.

Definition k1 a N : nat := ((ord a N) / 2) + 1.
Definition k2 a N : nat := ((ord a N) / 2) - 1.

Lemma pr_outcome_sum_cnttrue : forall l u f,
  pr_outcome_sum (uniform l u) f 
  = (INR (cnttrue (u - l) (fun x => f (l + x)%nat)) / INR (u - l))%R.
Proof.
  intros l u f.
  unfold uniform.
  (* shouldn't be too hard... -KH *)
Admitted.

(* Fact #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factoring_succeeds : forall N,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  let leads_to_factor a := nontrivgcd a N ||
                           nontrivgcd (a ^ k1 a N) N ||
                           nontrivgcd (a ^ k2 a N) N in
   pr_outcome_sum (* or r_interval *)
     (uniform 2 N)
     (fun x => leads_to_factor x)
   >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  specialize (reduction_factor_order_finding p k q H0 H1 H3 H4 H5) as H.
  rewrite <- H6 in *.
  rewrite pr_outcome_sum_cnttrue.
  (* ... -KH *)
Admitted.

Definition is_a_factor x y := exists z, (1 < z < y)%nat /\ y = (z * x)%nat.

Lemma end_to_end_shors_correct : forall N rnds niter x,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  end_to_end_shors N rnds O niter = Some x ->
  is_a_factor x N.
Proof.
  (* Should be easy(?) -KH *)
Admitted.

Local Opaque uniform shor_body.

Lemma end_to_end_shors_succeeds_with_high_probability : forall N rnds niter pr,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  (niter > 0)%nat ->
  r_interval
     (fun rnd => ssrbool.isSome (end_to_end_shors N rnds O niter) = true)
     pr ->
  pr >= ((1 / 2) * (κ / INR (Nat.log2 N)^4)) ^ niter.
Proof.
  intros.
  destruct niter; try lia.
  simpl in H3.
  (* @Robert, @Yuxiang: this is where I'm stuck :)

     We need some notion that: since we call sample and end_to_end_shors on 
     different indices of rnds, we can multiply together their probabilities.

     One iteration should succeed with probability 1/2 * κ / (Nat.log2 N)^4
     and separate iterations should be independent.
   *)

Admitted.



