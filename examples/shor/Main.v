Require Import Shor.
Require Import euler.Primes.
Require Import euler.AltPrimes.
Require Import AltGateSet.
Require Import AltShor.
Require Import Run.


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n (N : nat) := Nat.log2 (2 * N^2).
Definition k (N : nat) := AltShor.num_qubits (Nat.log2 (2 * N)).

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

   Inputs:
     N = number to factor
     rnds = stream of random real values
     i = index into rnds
     niter = max number of iterations
   
   Output:
     None or Some x where x is a nontrivial factor of N.

   Algorithm: Up to a maximum number of iterations, select "a" uniformly from 
   [2,n-1] and
     1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
     2. Measure the first n qubits, resulting in the n-bit number x.
     3. Run continued fraction expansion (= OF_post) to get r, which is a 
        candidate for the order (ord a N).
     4. Use r to try to factor N.

  The probability of success (returning Some) and the resources (aka qubits and 
  gates) used is a function of N and niter (see proofs below). *)

(* Uniform sampling in the range [lower, upper) *)
Definition uniform (lower upper : nat) : list R :=
  repeat 0 lower ++ repeat (1/ INR (upper - lower))%R (upper - lower).

(* N   : number to factor
   out : outcome from sampling *)
Definition process N size_a out :=
  let n := n N in
  let k := k N in
  let a := first_k size_a (size_a + (n + k)) out in
  let x := last_k (n + k) (size_a + (n + k)) out in
  (* try to factor *)
  if Nat.gcd a N =? 1%nat
  then factor a N (OF_post a N (first_k n (n + k) x) n)
  else Some (Nat.gcd a N).

(* N   : number to factor
   rnd : source of randomness for sampling *)
Definition shor_body N rnd :=
  let n := n N in
  let k := k N in
  (* create a distribution corresponding to choosing an 'a' and running
     Shor's circuit with this value 
     NOTE: we don't actually need to run the circuit in the case where a is not
     coprime to N, but it's easier to write the code this way *)
  let distr := join (uniform 1 N) 
                    (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
  (* sample from the distribution *)
  let out := sample distr rnd in
  (* try to factor *)
  process N (Nat.log2_up (N - 1)) out.

Definition end_to_end_shors N rnds :=
  iterate rnds (shor_body N).

(** Correctness properties for Shor's **)

Definition coprime (a b : nat) : Prop := Nat.gcd a b = 1%nat.

Lemma nth_run_probability_of_outcome : forall n (c : base_ucom n) x,
  (x < 2 ^ n)%nat ->
  nth x (run c) 0 
    = probability_of_outcome 
        (basis_vector (2^n) x) 
        (UnitarySem.uc_eval c × basis_vector (2^n) 0).
Proof.
  intros n c x Hx.
  unfold run, probability_of_outcome.
  rewrite nth_indep with (d':=Cmod2 0).
  rewrite map_nth.
  remember (UnitarySem.uc_eval c × basis_vector (2 ^ n) 0) as ψ.
  rewrite nth_vec_to_list by assumption.
  rewrite (basis_vector_decomp ψ) at 2.
  rewrite Mmult_vsum_distr_l.
  symmetry.
  erewrite vsum_unique.
  2 : { exists x. split. assumption. 
        split.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_eq.
        reflexivity. assumption.
        intros y Hy Hxy.
        rewrite Mscale_mult_dist_r.
        rewrite basis_vector_product_neq by auto.
        lma. }
  unfold Cmod, Cmod2.
  rewrite pow2_sqrt.
  unfold I, scale.
  simpl.
  lra.
  apply Rplus_le_le_0_compat; apply pow2_ge_0.
  subst. 
  apply WF_mult.
  apply WF_uc_eval.
  apply basis_vector_WF.
  apply pow_positive. lia.
  rewrite map_length.  
  rewrite vec_to_list_length.
  assumption.
Qed.

Lemma divmod_decomp :
  forall x y z r,
    (r > 0)%nat ->
    (z < r)%nat ->
    (x = y * r + z <-> x / r = y /\ x mod r = z)%nat.
Proof.
  split; intros.
  - split. symmetry. apply Nat.div_unique with (r := z); try lia.
    symmetry. apply Nat.mod_unique with (q := y); try lia.
  - destruct H1.
    replace (y * r)%nat with (r * y)%nat by lia.
    rewrite <- H1, <- H2.
    apply Nat.div_mod.
    lia.
Qed.

Lemma split_basis_vector : forall m n x y,
  (x < 2 ^ m)%nat ->
  (y < 2 ^ n)%nat ->
  basis_vector (2 ^ (m + n)) (x * 2 ^ n + y) 
    = basis_vector (2 ^ m) x ⊗ basis_vector (2 ^ n) y.
Proof.
  intros m n x y Hx Hy.
  unfold kron, basis_vector.
  solve_matrix.
  bdestruct (y0 =? 0).
  - repeat rewrite andb_true_r.
    assert (2^n > 0)%nat.
    { assert (0 < 2^n)%nat by (apply pow_positive; lia). lia.
    }
    specialize (divmod_decomp x0 x y (2^n)%nat H0 Hy) as G.
    bdestruct (x0 =? x * 2 ^ n + y).
    + apply G in H1. destruct H1.
      rewrite H1, H2. do 2 rewrite Nat.eqb_refl. lca.
    + bdestruct (x0 / 2 ^ n =? x); bdestruct (x0 mod 2 ^ n =? y); try lca.
      assert ((x0 / 2 ^ n)%nat = x /\ x0 mod 2 ^ n = y) by easy.
      apply G in H4.
      easy.
  - repeat rewrite andb_false_r.
    lca.
Qed.

Lemma rewrite_pr_outcome_sum : forall n k (c : base_ucom (n + k)) f,
  pr_outcome_sum (run c) (fun x => f (first_k n (n + k) x)) 
  = Rsum (2 ^ n) (fun x => ((if f x then 1 else 0) *
                         prob_partial_meas (basis_vector (2 ^ n) x) 
                           (UnitarySem.uc_eval c × basis_vector (2 ^ (n + k)) 0))%R).
Proof.
  intros n k c f.
  unfold pr_outcome_sum.
  unfold run at 1.
  rewrite map_length.
  rewrite vec_to_list_length.
  rewrite nested_Rsum.
  apply Rsum_eq_bounded.
  intros x Hx.
  destruct (f x) eqn:fx.
  rewrite Rmult_1_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. 
       rewrite Nat.mul_comm.
       rewrite simplify_first_k by assumption.
       rewrite fx.
       rewrite nth_run_probability_of_outcome.
       reflexivity.
       replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
       nia.
  }
  unfold prob_partial_meas.
  erewrite Rsum_eq_bounded.
  reflexivity.
  intros y Hy. 
  rewrite Nat.mul_comm.
  rewrite split_basis_vector by assumption.
  replace (2 ^ (n + k))%nat with (2 ^ n * 2 ^ k)%nat by unify_pows_two.
  reflexivity.
  rewrite Rmult_0_l.
  erewrite Rsum_eq_bounded.
  2: { intros y Hy. rewrite Nat.mul_comm. rewrite simplify_first_k by assumption.
       rewrite fx. reflexivity. }
  apply Rsum_0.
  reflexivity.
Qed.

(* Main lemma #1 - the probability that shor_body returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.Shor_correct_full). *)
Lemma shor_body_returns_order : forall (a N : nat),
  (0 < a < N)%nat ->
  coprime a N ->
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  pr_outcome_sum 
      (run (to_base_ucom (n + k) circ))
      (fun x => OF_post a N (first_k n (n + k) x) n =? ord a N) 
    >= κ / INR (Nat.log2 N)^4.
Proof.
  intros a N Ha1 Ha2 n0 k0 circ.
  subst n0 k0 circ.
  remember (fun x => OF_post a N x (n N) =? ord a N) as f'.
  replace (fun x : nat => OF_post a N (first_k (n N) (n N + k N) x) (n N) =? ord a N) 
    with (fun x : nat => f' (first_k (n N) (n N + k N) x)).
  rewrite rewrite_pr_outcome_sum.
  specialize (Shor.Shor_correct_full a N Ha1 Ha2) as H1.
  specialize (shor_circuit_same a N) as H2.
  unfold prob_shor_outputs in H2.
  erewrite Rsum_eq.
  2: { intro i. rewrite H2. reflexivity. lia. }
  unfold probability_of_success_var in H1.
  unfold n in *.
  unfold k in *.
  unfold r_found in H1.
  subst f'.
  apply H1.
  subst f'.
  reflexivity.
Qed.

Lemma nth_repeat : forall n r i,
  (i < n)%nat -> nth i (repeat r n) 0 = r.
Proof.
  intros n r i Hi.
  rewrite nth_indep with (d':=r).
  clear Hi.
  gen i.
  induction n; intro i; simpl; destruct i; try reflexivity.
  apply IHn.
  rewrite repeat_length.
  assumption.
Qed.

Lemma pr_outcome_sum_cnttrue : forall l u f,
  (l < u)%nat ->
  pr_outcome_sum (uniform l u) f 
  = (INR (cnttrue (u - l) (fun x => f (l + x - 1)%nat)) / INR (u - l))%R.
Proof.
  intros l u f H.
  unfold uniform.
  rewrite pr_outcome_sum_append.
  rewrite pr_outcome_sum_repeat_false.
  rewrite Rplus_0_l.
  remember (u - l)%nat as n.
  assert (Hn:(n > 0)%nat) by lia.
  clear - Hn.
  unfold pr_outcome_sum.
  rewrite 2 repeat_length.
  erewrite Rsum_eq_bounded.
  2: { intros i Hi.
       replace  (if f (l + i)%nat then nth i (repeat (1 / INR n)%R n) 0 else 0) with
           ((1 / INR n)%R * (if f (l + i)%nat then 1 else 0))%R.
       reflexivity.
       destruct (f (l + i)%nat).
       rewrite nth_repeat by assumption.
       lra.
       lra. }
  rewrite <- Rsum_scale.
  replace (INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)) / INR n)%R with (1 / INR n * INR (cnttrue n (fun x : nat => f (l + x - 1)%nat)))%R by lra.
  apply f_equal2; try reflexivity.
  clear Hn.
  induction n.
  reflexivity.
  rewrite Rsum_extend.
  simpl.
  rewrite IHn.
  replace (l + S n0 - 1)%nat with (l + n0)%nat by lia.
  destruct (f (l + n0)%nat); try lra. 
  rewrite S_O_plus_INR.
  simpl.
  reflexivity.
Qed.

Definition leads_to_factor N a := 
  nontrivgcd a N ||
  (nontrivgcd (a ^ ((ord a N) / 2)%nat - 1) N ||
   nontrivgcd (a ^ ((ord a N) / 2)%nat + 1) N).

(* Main lemma #2 - Assuming that N is not prime, not even, and not a power of a prime,
   for a random choice of a, the probability that ord(a,N) can be used to find 
   a factor is at least 1/2. *) 
Lemma shor_factoring_succeeds : forall N,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
   pr_outcome_sum
     (uniform 1 N)
     (fun x => leads_to_factor N x)
   >= 1 / 2.
Proof.
  intros.
  apply simplify_primality in H; trivial. clear H0 H1.
  destruct H as [p [k [q [H0 [H1 [H3 [H4 [H5 H6]]]]]]]].
  assert (H :( N - 1 <= 2 * cnttrue (N - 1) (leads_to_factor N))%nat).
  subst N.
  apply reduction_factor_order_finding; auto.
  assert (2 < N)%nat.
  subst N. 
  rewrite <- (Nat.mul_1_l 2).
  apply Nat.mul_lt_mono_nonneg; try lia.
  apply Nat.pow_gt_1; lia.
  rewrite pr_outcome_sum_cnttrue by lia.
  erewrite cnttrue_same.
  2 : { intros x Hx. replace (2 + x - 1)%nat with (x + 1)%nat by lia. reflexivity. }
  rewrite cnttrue_same with (g := leads_to_factor N).
  apply le_INR in H. rewrite mult_INR in H. replace (INR 2) with 2 in H by easy.
  unfold Rdiv.
  assert (0 < INR (N - 1)).
  { apply lt_0_INR. lia. }
  assert (0 < / INR (N - 1)).
  { apply Harmonic.INR_inv_pos. lia. }
  apply Rmult_le_compat_r with (r := (/ INR (N - 1))%R) in H; try lra.
  rewrite Rinv_r in H by lra.
  apply Rmult_le_compat_l with (r := 2%R) in H; try lra.
  intros. f_equal. lia.
Qed.

Definition is_a_factor x y := exists z, (1 < z < y)%nat /\ y = (z * x)%nat.

Lemma gcd_is_factor : forall x y, (1 < Nat.gcd x y < y)%nat -> is_a_factor (Nat.gcd x y) y.
Proof.
  intros x y H.
  unfold is_a_factor.
  specialize (Nat.gcd_divide_r x y) as G. destruct G.
  exists x0.
  split; try lia.
  split; nia.
Qed.

Lemma factor_returns_factor : forall a N r x,
  factor a N r = Some x -> is_a_factor x N.
Proof.
  intros a N r x H.
  unfold factor in H.
  remember (Nat.gcd (a ^ (r / 2) - 1) N) as k1.
  remember (Nat.gcd (a ^ (r / 2) + 1) N) as k2.
  bdestruct (1 <? k1); bdestruct (k1 <? N); 
    bdestruct (1 <? k2); bdestruct (k2 <? N); 
    simpl in H; inversion H; subst;
    apply gcd_is_factor; auto.
Qed.

Lemma sample_uniform_lb :
  forall m l r,
    0 <= r ->
    (m <= sample (repeat 0%R m ++ l) r)%nat.
Proof.
  induction m; intros.
  lia. simpl.
  destruct (Rlt_le_dec r 0). lra.
  specialize (IHm l r H).
  replace (r - 0)%R with r by lra.
  lia.
Qed.

Lemma sample_boom :
  forall l r,
    Forall (fun x => 0 <= x) l ->
    Rsum (length l) (fun i => nth i l 0) <= r ->
    sample l r = length l.
Proof.
  induction l; intros. easy.
  simpl. rewrite Rsum_list_extend in H0.
  inversion H; subst.
  specialize (Rsum_list_geq_0 l H4) as G.
  assert (Rsum (length l) (fun i : nat => nth i l 0) <= r - a)%R by lra.
  specialize (IHl (r - a)%R H4 H1) as T. rewrite T.
  destruct (Rlt_le_dec r a). lra. lia.
Qed.

Lemma sample_extend :
  forall l1 l2 r,
    Forall (fun x => 0 <= x) l1 ->
    Forall (fun x => 0 <= x) l2 ->
    Rsum (length l1) (fun i => nth i l1 0) <= r ->
    (sample (l1 ++ l2) r = (length l1) + sample l2 (r - Rsum (length l1) (fun i => nth i l1 0%R)))%nat.
Proof.
  induction l1; intros.
  - simpl. f_equal. lra.
Local Opaque Rsum.
  - rewrite Rsum_list_extend in *. simpl.
    inversion H; subst.
    specialize (Rsum_list_geq_0 l1 H5) as G.
    destruct (Rlt_le_dec r a); try lra.
    f_equal. rewrite IHl1; try easy; try lra.
    f_equal. f_equal. lra.
Qed.
Local Transparent Rsum.

Lemma sample_ub :
  forall l r, (sample l r <= length l)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma sample_ub_less :
  forall l r, 0 <= r < Rsum (length l) (fun i => nth i l 0) -> (sample l r < length l)%nat.
Proof.
  induction l; intros. simpl in H. lra.
  simpl. destruct (Rlt_le_dec r a). lia.
  apply lt_n_S. apply IHl. rewrite Rsum_list_extend in H. lra.
Qed.

Lemma sample_lb :
  forall l r, (0 <= sample l r)%nat.
Proof.
  induction l; intros. easy.
  simpl. specialize (IHl (r - a)%R). destruct (Rlt_le_dec r a); lia.
Qed.

Lemma repeat_gt0 :
  forall m r, 0 <= r -> Forall (fun x => 0 <= x) (repeat r m).
Proof.
  induction m; intros. simpl. constructor.
  simpl. constructor. easy. apply IHm. easy.
Qed.

Lemma Rsum_repeat :
  forall m r, (Rsum (length (repeat r m)) (fun i => nth i (repeat r m) 0) = (INR m) * r)%R.
Proof.
  intros. induction m. simpl. lra.
  replace (repeat r (S m)) with (r :: repeat r m).
  rewrite Rsum_list_extend, IHm. rewrite S_INR. lra.
  easy.
Qed.

Lemma sample_uniform : forall l u r, (l < u)%nat -> 0 <= r < 1 -> (l <= sample (uniform l u) r < u)%nat.
Proof.
  intros. split.
  - unfold uniform. apply sample_uniform_lb. easy.
  - unfold uniform. rewrite sample_extend. rewrite repeat_length.
    assert (T: (forall a b c, a < c -> b < c - a -> a + b < c)%nat) by (intros; lia).
    apply T. easy.
    replace (u - l)%nat with (length (repeat (1 / INR (u - l))%R (u - l))) at 3 by apply repeat_length.
    apply sample_ub_less.
    replace l with (length (repeat 0 l)) at 1 2 by apply repeat_length.
    repeat rewrite Rsum_repeat.
    replace (INR (u - l) * (1 / INR (u - l)))%R with (INR (u - l) * / INR (u - l))%R by lra.
    rewrite Rinv_r. lra.
    apply not_0_INR. lia.
    apply repeat_gt0; lra.
    apply repeat_gt0. unfold Rdiv. rewrite Rmult_1_l.
    apply Rlt_le, Harmonic.INR_inv_pos. lia.
    rewrite Rsum_repeat. lra.
Qed.

Local Opaque uniform.
Lemma end_to_end_shors_correct : forall N rnds x,
    (1 < N)%nat ->
    (Forall (fun x => 0 <= x < 1) rnds) ->
    end_to_end_shors N rnds = Some x ->
    is_a_factor x N.
Proof.
  (*
  intros N rnds niter x H Hrnds H0.
  unfold end_to_end_shors in H0.
  induction niter; intros.
  inversion H0.
  simpl in H0.
  destruct (shor_body N (rnds niter)) eqn:sb; auto.
  inversion H0; subst.
  unfold shor_body, process in sb.
  (* first, some cleanup *)
  remember (join (uniform 1 N)
                 (fun a : nat =>
                    run (to_base_ucom (n N + k N) (shor_circuit a N)))) as distr.
  remember (Nat.log2_up (N - 1)) as len.
  remember (first_k len (len + (n N + k N)) (sample distr (rnds niter))) as a.
  remember (last_k (n N + k N) (len + (n N + k N)) (sample distr (rnds niter))) as o.
  (* now back to the proof... *)
  bdestruct (Nat.gcd a N =? 1).
  apply factor_returns_factor in sb. 
  auto.
  inversion sb.
  apply gcd_is_factor.
  assert (0 < a < N)%nat.
  (* this might be a little annoying because it requires showing that (first_k ...)
     ends up with something from the uniform distirbution. Given that, we can use
     the sample_uniform lemma. *)
  admit.
  assert (0 < Nat.gcd a N)%nat.
  apply Natgcd_pos; lia.
  assert (Nat.gcd a N <= a)%nat.
  rewrite Nat.gcd_comm.
  apply Misc.Nat_gcd_le_r.
  lia. 
  lia.
  *)
Admitted.

Lemma geq_exists : forall a b,
  a >= b -> exists c, a = c /\ c >= b.
Proof. intros a b H. exists a. split; auto. Qed.

Lemma length_run : forall n (c : base_ucom n),
  length (run c) = (2 ^ n)%nat. 
Proof.
  intros n c.
  unfold run.
  rewrite map_length.
  rewrite vec_to_list_length.
  reflexivity.
Qed.

Lemma uniform_distribution : forall a b, 
  (a < b)%nat -> distribution (uniform a b).
Proof.
(* shouldn't be too hard -Kesha *)
Admitted.

Lemma run_distribution : forall {dim} c, 
  distribution (@run dim c).
Proof.
(* should be able to use the fact that uc_eval produces a unitary -Kesha *)
Admitted.

Lemma shor_body_succeeds_with_high_probability' : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    let un_sz := Nat.log2_up (N - 1) in
    let f1 a := leads_to_factor N a in
    let f2 a x := (OF_post a N (first_k n (n + k) x) n =? ord a N) ||
                  negb (Nat.gcd a N =? 1) in
    pr_outcome_sum distr
      (fun z => let x := first_k un_sz (un_sz + (n + k)) z in
             let y := last_k (n + k) (un_sz + (n + k)) z in
             f1 x && f2 x y)
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros.
  apply pr_outcome_sum_join_geq.
  apply uniform_distribution.
  admit. (* implied by H, H0, H1 *)
  admit. (* definitely true, requires a little math *)
  apply shor_factoring_succeeds; auto.
  intros i Hi.
  split.
  apply length_run.
  subst f2.
  specialize (run_distribution (to_base_ucom (n0 + k0) (shor_circuit i N))) as Hdist.
  bdestruct (Nat.gcd i N =? 1).
  eapply Rge_trans.
  apply Rle_ge.
  apply pr_outcome_sum_orb.
  destruct Hdist as [Hdist _]; auto.
  apply shor_body_returns_order.
  admit. (* implied by H2 *)
  unfold coprime.
  assumption.
  rewrite pr_outcome_sum_true.
  destruct Hdist as [_ Hdist].
  rewrite Hdist.
  admit. (* requires some math *)
  intros j Hj.
  bdestructΩ (Nat.gcd i N =? 1).
Admitted.

Lemma shor_body_succeeds_with_high_probability : forall N,
    ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
    let n := n N in
    let k := k N in
    let distr := join 
                   (uniform 1 N) 
                   (fun a => run (to_base_ucom (n + k) (shor_circuit a N))) in
    pr_outcome_sum distr (fun x => isSome (process N (Nat.log2_up (N - 1)) x))
      >= (1 / 2) * (κ / INR (Nat.log2 N)^4).
Proof.
  intros N HN1 HN2 HN3 n k distr.
  assert (Hdist: distribution distr).
  subst distr. 
  apply distribution_join.
  apply uniform_distribution.
  admit. (* implied by assumptions about N *)
  intros i Hi.
  apply run_distribution.
  apply Rle_ge.
  eapply Rle_trans.
  apply Rge_le.
  apply shor_body_succeeds_with_high_probability'; auto.
  apply pr_outcome_sum_implies.
  destruct Hdist as [Hdist _]; auto.
  simpl.
  intros x H.
  unfold process.
  subst n k.
  remember (first_k (Nat.log2_up (N - 1))
           (Nat.log2_up (N - 1) + (Main.n N + Main.k N)) x) as a.
  remember (last_k (Main.n N + Main.k N)
           (Nat.log2_up (N - 1) + (Main.n N + Main.k N)) x) as y.
  clear - H.
  destruct (Nat.gcd a N =? 1); auto.
  unfold factor.
  unfold leads_to_factor, nontrivgcd, nontriv in H.
  remember (OF_post a N (first_k (n N) (n N + k N) y) (n N)) as z.
  clear Heqz.
  apply andb_prop in H as [H1 H2].
  simpl in H2.
  rewrite orb_false_r in H2.
  Local Opaque Nat.div.
  bdestructΩ (z =? ord a N); subst.
  remember (a ^ (ord a N / 2) + 1)%nat as ap1.
  remember (a ^ (ord a N / 2) - 1)%nat as am1.
  (* blah. I'll look at this later. -Kesha *)
Admitted.


Lemma pr_outcome_sum_geq_exists : forall l f r,
  distribution l ->
  pr_outcome_sum l f >= r ->
  exists r0, (r0 >= r)%R /\ pr_P (fun rnd => f (sample l rnd) = true) r0.
Proof.
  intros l f r  HlHr.
  exists (pr_outcome_sum l f).
  split; auto.
  apply pr_outcome_sum_eq_aux; auto.
Qed.

(* For n iterations of end_to_end_shors, the probability of success is
   1 - (1 - ((1 / 2) * (κ / INR (Nat.log2 N)^4))^n). *)
Local Opaque pow leads_to_factor.
Lemma end_to_end_shors_succeeds_with_high_probability : forall N niter r,
  ~ (prime N) -> Nat.Odd N -> (forall p k, prime p -> N <> p ^ k)%nat ->
  (niter > 0)%nat ->
  pr_Ps (fun rnds => isSome (end_to_end_shors N rnds) = true) niter r ->
  (r >= 1 - (1 - ((1 / 2) * (κ / INR (Nat.log2 N)^4))^niter))%R.
Proof.
  (*
  intros N niter r HN1 HN2 HN3 Hniter H.
  unfold end_to_end_shors in H.
  specialize (shor_body_succeeds_with_high_probability N HN1 HN2 HN3) as Hbody.
  apply pr_outcome_sum_geq_exists in Hbody.
  destruct Hbody as [r0 [? ?]].
  apply pr_iterate_Some with (niter0:=niter) in H1.
  eapply pr_Ps_unique in H. (* can we rephrase the lemma to get around the need for uniqueness? -Kesha *)
  2: apply H1.
  subst r.
  remember (1 / 2 * (κ / INR (Nat.log2 N) ^ 4)) as β.
  clear H1.
  apply Rle_ge.
  (* pretty sure this is true -Kesha *)
  admit.
  assumption.
  apply distribution_join.
  apply uniform_distribution.
  admit. (* implied by assumptions about N *)
  intros i Hi.
  apply run_distribution.
  apply distribution_join.
  apply uniform_distribution.
  admit. (* implied by assumptions about N *)
  intros i Hi.
  apply run_distribution.
   *)
Admitted.


(** TODO @Yuxiang: facts about end_to_end_shors resources **)
