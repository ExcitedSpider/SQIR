Require Import Shor.
Require Import euler.Primes.
Require Import AltGateSet.
Require Import AltShor.

(* The definitions and proofs in this file are largely wrappers around definitions
   and proofs in other files. At some point, I might clean up the code in the 
   other files directly so this file won't be necessary. -KH *)


(** Coq definitions that will be extracted to OCaml **)

(* Shor's runs on (n + k) qubits and returns the result of measuring n qubits. *)
Definition n N := Nat.log2 (2 * N^2)%nat.
Definition k N := AltShor.num_qubits (Nat.log2 (2 * N)).

(* Shor circuit *)
Definition shor_circuit (a N : nat) := AltShor.shor_circuit a N. 

(* Continued fraction expansion *)
Definition cont_frac_exp (a N o : nat) := Shor.OF_post a N o (n N).

(* (run_circuit dim n cir) will produce the result of running cir on the dim-qubit 
   zero state and measuring the first n qubits.

   run_circuit will be extracted to a function that calls the ddsim simulator
   and chooses a measurement result based on 10000 trials. We use multiple 
   trials to cheat a little, so we can "re-run" the circuit without additional 
   simulation.

   TODO: we should have some correctness axiom for run_circuit that says that
   it behaves identically to our uc_eval function.  *)
Parameter run_circuit : nat -> nat -> ucom U -> nat.

(* given r = ord(a,N), try to find a factor of N (based on Shor.Factor_post) *)
Definition factor (a N r : nat) := 
  let cand1 := Nat.gcd (a ^ (r / 2) - 1) N in
  let cand2 := Nat.gcd (a ^ (r / 2) + 1) N in 
  if (1 <? cand1) && (cand1 <? N) then Some cand1      (* candidate #1 is a factor *)
  else if (1 <? cand2) && (cand2 <? N) then Some cand2 (* candidate #2 is a factor *)
  else None.                                           (* failed to find factor *)

(* End-to-end definition of Shor's algorithm.

1. Run the circuit generated by (shor_circuit a N) on input  ∣0⟩_{n + k}.
2. Measure the first n qubits, resulting in the n-bit number x.
3. Run cont. frac. expansion to get r, which is a candidate for the order (ord a N).
4. Use r to try to factor N.

  The probability that cont_frac_exp correctly returns (ord a N) is at least
  1/polylog(N), as shown in shor_OF_correct. The probability that factor
  returns a factor of N (given the correct order) is at least 1/2, as shown
  in shor_factor_correct. *)
Definition end_to_end_shors a N :=
  let n := n N in
  let k := k N in
  let circ := shor_circuit a N in
  let x := run_circuit (n + k) n circ in
  let r := cont_frac_exp a N x in
  factor a N r.


(** Some utilities for stating correctness properties. **)

(* The probability that measuring the first m qubits of v produces x. *)
Definition prob_meas_outcome m n (v : Vector (2^(m+n))) x :=
  @prob_partial_meas _ n (basis_vector (2^m) x) v.

(* The probability that the result of measuring the first m qubits of v 
   satisfies predicate f. *)
Definition prob_meas_outcome_sats_pred m n (v : Vector (2^(m+n))) (f : nat -> bool) :=
  Rsum (2^m) (fun x => if f x then prob_meas_outcome m n v x else 0).

(* The probability that a number < Nmax satisfies predicate f
   (i.e. the # of values that satisfy f divided by Nmax) *)
Definition prob_value_sats_pred Nmax f : R :=
  INR (ShorAux.cnttrue Nmax f) / INR Nmax.

(* The probability that a number < Nmax satisfies predicate f, given that
   it satisfies predicate g (i.e. the # of values that satisfy f & g divided 
   by the # of values that satisfy g) *)
Definition cond_prob_value_sats_pred Nmax f g : R :=
  prob_value_sats_pred Nmax (fun x => f x && g x) / prob_value_sats_pred Nmax g.


(** Correctness properties for Shor's **)

(* Axiom #1 - we will want some axiom that says that run_circuit returns
   outputs in accordance with the distribution of uc_eval.
   
   Below is an attempt, but I don't think it's what we want for shor_OF_correct. -KH *)
Axiom run_circuit_correct : forall m n (u : ucom U) x,
  let v := @Mmult _ _ 1 (uc_eval (m + n) u) (basis_vector (2 ^ (m + n)) 0) in
  cond_prob_value_sats_pred 
      (2 ^ m) (fun x0 => x0 =? x) (fun x0 => x0 =? run_circuit (m + n) m u)
    = prob_meas_outcome m n v x.

(* Fact #1 - the probability that run_circuit returns ord(a,N) is at least 
   κ / (Nat.log2 N)^4 where κ is about 0.055 (see Shor.v).

   This is awkward because I describe "the probability that run_circuit +
   cont_frac_exp returns ord(a,N)" using cond_prob_value_sats_pred. I'm pretty
   such that the axiom above won't let me prove this... suggestions? -KH *)
Lemma shor_OF_correct : forall (a N : nat),
  (0 < a < N)%nat ->
  (Nat.gcd a N = 1)%nat ->
  cond_prob_value_sats_pred 
      (2 ^ n N)
      (fun x => x =? ord a N)
      (fun x => x =? cont_frac_exp a N (run_circuit (n N + k N) (n N) (shor_circuit a N)))
    >= κ / INR (Nat.log2 N)^4.
Proof.
Admitted.

(* Fact #2 - Assuming that N has the form (p ^ k * q) for prime p > 2, k > 0, 
   q > 2, and p ^ k coprime to q...
   the probability that ord(a,N) can be used to find a factor is at least 1/2.

   TODO: Can we state the constraint on N in a more succint way? I think what we 
   have now is equivalent to saying that N is not prime, not even, and not a power
   of a prime. Do we have a proof of this? -KH *) 
Definition k1 a N : nat := ((ord a N) / 2) + 1.
Definition k2 a N : nat := ((ord a N) / 2) - 1.
Definition coprime a b := Nat.gcd a b = S O.
Definition nontrivial_factor a b := 
  (a <? b) && (1 <? Nat.gcd a b) && (Nat.gcd a b <? b).

Lemma shor_factor_correct : forall p k q N a,
  (k <> 0)%nat -> prime p -> (p > 2)%nat -> (q > 2)%nat -> coprime (p ^ k) q ->
  N = (p ^ k * q)%nat ->
  coprime a N -> 
  let is_a_factor x := nontrivial_factor (a ^ k1 a N) N || 
                         nontrivial_factor (a ^ k2 a N) N in
  cond_prob_value_sats_pred N is_a_factor (fun a => Nat.gcd a N =? 1) >= 1/2.
Proof.
  intros.
  unfold cond_prob_value_sats_pred.
  apply Rle_ge.
  apply Generic_proof.Rdiv_ge_mult_pos.
  lra.
  rewrite Rdiv_unfold, <- Rmult_assoc, <- Rdiv_unfold.
  apply Generic_proof.Rdiv_le_mult_pos.
  (* probably true -KH *) admit.
  rewrite Rmult_1_l.
  replace (fun x : nat => is_a_factor x && (Nat.gcd x N =? 1))
    with (fun x : nat => (Nat.gcd x N =? 1) && is_a_factor x).
  subst N.
  unfold prob_value_sats_pred.
  (* should be able to get this out of ShorAux.reduction_factor_order_finding *)
  admit.
Admitted.


(* Goal:

Given a < N s.t. a and N are coprime, there is at least a 1/2 * κ / (Nat.log2 N)^4
probability that Shor's algorithm returns a non-trivial factor of N. *)

